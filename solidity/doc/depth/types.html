<!DOCTYPE html><html class="no-js" lang="zh-cn"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>类型 - 精通以太坊</title><meta name="generator" content="Hugo 0.31.1"><meta name="description" content="从零成长为以太坊高级开发者"><link rel="canonical" href="http://ethereum.mochain.info/solidity/doc/depth/types.html"><meta name="author" content="虞双齐"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="32x32" href="http://ethereum.mochain.info/images/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="精通以太坊"><link rel="apple-touch-icon-precomposed" href="http://ethereum.mochain.info/images/app-icon64x64.png"><meta name="msapplication-TileImage" content="/images/app-icon128x128.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:url" content="http://ethereum.mochain.info/solidity/doc/depth/types.html"><meta property="og:title" content="精通以太坊"><meta property="og:image" content="http://ethereum.mochain.info/images/logo.png"><meta name="apple-mobile-web-app-title" content="精通以太坊"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="lang:clipboard.copy" content="Copy to clipboard"><meta name="lang:clipboard.copied" content="Copied to clipboard"><meta name="lang:search.language" content="en"><meta name="lang:search.result.none" content="No matching documents"><meta name="lang:search.result.one" content="1 matching document"><meta name="lang:search.result.other" content="# matching documents"><meta name="lang:search.tokenizer" content="[\s\-]+"><link rel="shortcut icon" type="image/x-icon" href="http://ethereum.mochain.info/images/favicon.ico"><link rel="icon" type="image/x-icon" href="http://ethereum.mochain.info/images/favicon.ico"><style>@font-face{font-family:Icon;src:url(http://ethereum.mochain.info/fonts/icon.eot);src:url(http://ethereum.mochain.info/fonts/icon.eot) format('embedded-opentype'),url(http://ethereum.mochain.info/fonts/icon.woff) format('woff'),url(http://ethereum.mochain.info/fonts/icon.ttf) format('truetype'),url(http://ethereum.mochain.info/fonts/icon.svg) format('svg');font-weight:400;font-style:normal}</style><link rel="stylesheet" href="http://ethereum.mochain.info/stylesheets/application.css"><link rel="stylesheet" href="http://ethereum.mochain.info/stylesheets/palette.css"><link rel="stylesheet" href="//fonts.cat.net/css?family=Noto%20Sans%20CJK:400,700|Ubuntu&#43;Mono"><style>body,input{font-family:'Noto Sans CJK',Helvetica,Arial,sans-serif}code,pre{font-family:'Ubuntu Mono','Courier New',Courier,monospace}</style><link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons"><script src="http://ethereum.mochain.info/javascripts/modernizr.js"></script></head><body dir="ltr" data-md-color-primary="light-gren" data-md-color-accent="indigo"><svg class="md-svg"><defs><svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg></defs></svg> <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer"> <input class="md-toggle" data-md-toggle="search" type="checkbox" id="search"> <label class="md-overlay" data-md-component="overlay" for="drawer"></label> <a href="#getting-started" tabindex="1" class="md-skip">Skip to content</a><header class="md-header" data-md-component="header"><nav class="md-header-nav md-grid"><div class="md-flex"><div class="md-flex__cell md-flex__cell--shrink"><a href="http://ethereum.mochain.info" title="精通以太坊" class="md-header-nav__button md-logo"><i class="md-icon"></i></a></div><div class="md-flex__cell md-flex__cell--shrink"><label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label></div><div class="md-flex__cell md-flex__cell--stretch"><div class="md-flex__ellipsis md-header-nav__title" data-md-component="title"><span class="md-header-nav__topic">精通以太坊 </span><span class="md-header-nav__topic">类型</span></div></div><div class="md-flex__cell md-flex__cell--shrink"><label class="md-icon md-icon--search md-header-nav__button" for="search"></label></div><div class="md-flex__cell md-flex__cell--shrink"><div class="md-header-nav__source"><a href="https://github.com/ysqi/etheraction" title="Go to repository" class="md-source" data-md-source="github"><div class="md-source__icon"><svg viewBox="0 0 24 24" width="24" height="24"><use xlink:href="#github" width="24" height="24"></use></svg></div><div class="md-source__repository">ysqi/etheraction</div></a></div></div></div></nav></header><div class="md-container"><nav class="md-tabs md-tabs--active" data-md-component="tabs"><div class="md-tabs__inner md-grid"><ul class="md-tabs__list"><li class="md-tabs__item"><a href="http://ethereum.mochain.info/basic/" title="基础知识" class="md-tabs__link">基础知识</a></li><li class="md-tabs__item"><a href="http://ethereum.mochain.info/contract/" title="智能合约" class="md-tabs__link">智能合约</a></li><li class="md-tabs__item"><a href="http://ethereum.mochain.info/solidity/doc" title="Solidiy官方文档中文版" class="md-tabs__link md-tabs__link--active">Solidiy官方文档中文版</a></li><li class="md-tabs__item"><a href="http://ethereum.mochain.info/action" title="实战" class="md-tabs__link">实战</a></li><li class="md-tabs__item"><a href="http://ethereum.mochain.info/about" title="关于" class="md-tabs__link">关于</a></li></ul></div></nav><main class="md-main"><div class="md-main__inner md-grid" data-md-component="container"><div class="md-sidebar md-sidebar--primary" data-md-component="navigation"><div class="md-sidebar__scrollwrap"><div class="md-sidebar__inner"><nav class="md-nav md-nav--primary" data-md-level="0"><label class="md-nav__title md-nav__title--site" for="drawer"><span class="md-nav__button md-logo"><i class="md-icon"></i> </span>精通以太坊22</label><div class="md-nav__source"><a href="https://github.com/ysqi/etheraction" title="Go to repository" class="md-source" data-md-source="github"><div class="md-source__icon"><svg viewBox="0 0 24 24" width="24" height="24"><use xlink:href="#github" width="24" height="24"></use></svg></div><div class="md-source__repository">ysqi/etheraction</div></a></div><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-0" type="checkbox" id="nav-0"> <label class="md-nav__link" for="nav-0">基础知识</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-0">基础知识</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="http://ethereum.mochain.info/basic/" title="说明" class="md-nav__link">说明</a></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-0-1" type="checkbox" id="nav-0-1"> <label class="md-nav__link" for="nav-0-1">以太坊概念</label><nav class="md-nav" data-md-component="collapsible" data-md-level="2"><label class="md-nav__title" for="nav-0-1">以太坊概念</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="http://ethereum.mochain.info/basic/ethereum/gas.html" title="理解Gas" class="md-nav__link">理解Gas</a></li></ul></nav></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1"> <label class="md-nav__link" for="nav-1">智能合约</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-1">智能合约</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="http://ethereum.mochain.info/contract/" title="前言" class="md-nav__link">前言</a></li></ul></nav></li><li class="md-nav__item md-nav__item--active md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" checked="checked"> <label class="md-nav__link" for="nav-2">Solidiy官方文档中文版</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-2">Solidiy官方文档中文版</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/" title="简介" class="md-nav__link">简介</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/introduction-to-smart-contracts.html" title="智能合约介绍" class="md-nav__link">智能合约介绍</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/installing-solidity.html" title="安装 Solidity" class="md-nav__link">安装 Solidity</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/solidity-by-example.html" title="Solidity 示例" class="md-nav__link">Solidity 示例</a></li><li class="md-nav__item md-nav__item--active md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-4" type="checkbox" id="nav-2-4" checked="checked"> <label class="md-nav__link" for="nav-2-4">深入了解 Solidity</label><nav class="md-nav" data-md-component="collapsible" data-md-level="2"><label class="md-nav__title" for="nav-2-4">深入了解 Solidity</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/depth/layout-of-source-files.html" title="源文件布局" class="md-nav__link">源文件布局</a></li><li class="md-nav__item md-nav__item--active"><input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="toc"> <label class="md-nav__link md-nav__link--active" for="toc">类型</label> <a href="http://ethereum.mochain.info/solidity/doc/depth/types.html" title="类型" class="md-nav__link md-nav__link--active">类型</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/units-and-global-variables.html" title="单位和全局变量" class="md-nav__link">单位和全局变量</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/control-structures.html" title="表达式与控制结构" class="md-nav__link">表达式与控制结构</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/contracts.html" title="合约" class="md-nav__link">合约</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/assembly.html" title="Soldity 汇编" class="md-nav__link">Soldity 汇编</a></li></ul></nav></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3"> <label class="md-nav__link" for="nav-3">实战</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-3">实战</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="http://ethereum.mochain.info/action/" title="实战" class="md-nav__link">实战</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/action/game/" title="以太碟游戏" class="md-nav__link">以太碟游戏</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/action/lottery/" title="快3彩票" class="md-nav__link">快3彩票</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/action/token/" title="五彩石代币" class="md-nav__link">五彩石代币</a></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4"> <label class="md-nav__link" for="nav-4">关于</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-4">关于</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="http://ethereum.mochain.info/about/" title="关于本书" class="md-nav__link">关于本书</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/about/license.html" title="License" class="md-nav__link">License</a></li></ul></nav></li></ul></nav></div></div></div><div class="md-sidebar md-sidebar--secondary" data-md-component="toc"><div class="md-sidebar__scrollwrap"><div class="md-sidebar__inner"><nav class="md-nav md-nav--secondary"><h4 class="md-nav__title" for="toc">Table of Contents</h4><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="#%e5%80%bc%e7%b1%bb%e5%9e%8b" class="md-nav__link">值类型</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#booleans" class="md-nav__link">布尔型</a></li><li class="md-nav__item"><a href="#integers" class="md-nav__link">整数型</a></li><li class="md-nav__item"><a href="#fixed-point-numbers" class="md-nav__link">定点数</a></li><li class="md-nav__item"><a href="#address" class="md-nav__link">地址</a></li><li class="md-nav__item"><a href="#member-of-address" class="md-nav__link">地址成员</a></li><li class="md-nav__item"><a href="#fixed-size-byte-arrays" class="md-nav__link">定长字节数组</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#%e6%88%90%e5%91%98" class="md-nav__link">成员</a></li></ul></nav></li><li class="md-nav__item"><a href="#dynamically-sized-byte-array" class="md-nav__link">可变字节数组</a></li><li class="md-nav__item"><a href="#address-literals" class="md-nav__link">地址字面量</a></li><li class="md-nav__item"><a href="#rational-and-integer-literals" class="md-nav__link">有理数和整数字面量</a></li><li class="md-nav__item"><a href="#string-literal" class="md-nav__link">字符串字面量</a></li><li class="md-nav__item"><a href="#Hexadecimal-liternal" class="md-nav__link">十六进制字面量</a></li><li class="md-nav__item"><a href="#enum" class="md-nav__link">枚举</a></li><li class="md-nav__item"><a href="#function-type" class="md-nav__link">函数类型</a></li></ul></nav></li><li class="md-nav__item"><a href="#reference-types" class="md-nav__link">引用类型</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#data-location" class="md-nav__link">数据位置</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#%e5%b0%8f%e7%bb%93" class="md-nav__link">小结</a></li></ul></nav></li><li class="md-nav__item"><a href="#array" class="md-nav__link">数组</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#allocatiing-memory-arrays" class="md-nav__link">分配内存型数组</a></li><li class="md-nav__item"><a href="#array-literanls-inline" class="md-nav__link">数组字面量/内联数组</a></li><li class="md-nav__item"><a href="#memeber" class="md-nav__link">成员</a></li></ul></nav></li><li class="md-nav__item"><a href="#stucts" class="md-nav__link">结构</a></li></ul></nav></li><li class="md-nav__item"><a href="#mapping" class="md-nav__link">映射</a></li><li class="md-nav__item"><a href="#Operators%20Involving%20LValues" class="md-nav__link">左值运算</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#delete" class="md-nav__link">delete</a></li></ul></nav></li><li class="md-nav__item"><a href="#Conversions-between-Elementary-Types" class="md-nav__link">基础类型的类型转换</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#Implicit-Conversions" class="md-nav__link">隐式转换</a></li><li class="md-nav__item"><a href="#Explicit-Conversions" class="md-nav__link">显式转换</a></li></ul></nav></li><li class="md-nav__item"><a href="#Type-Deduction" class="md-nav__link">类型推导</a></li></ul></nav></div></div></div><div class="md-content"><article class="md-content__inner md-typeset"><a href="https://github.com/ysqi/etheraction/edit/master/content/solidity/doc/depth/types.md" title="" class="md-icon md-content__icon">&#xE3C9;</a><h1>类型</h1><p>Solidity 是一门静态类型语言，意味着每个变量（状态变量和局部变量）类型都需要在编译期确定（或至少是已知的见下方 <a href="#Type-Deduction">类型断言</a>）。 Solidity 提供了几个基础类型，可以组合成复杂类型。</p><p>此外，类型可在含运算符的表达式中交互。快速查阅各种运算，请见<a href="http://solidity.readthedocs.io/en/latest/miscellaneous.html#order">运算符优先级</a></p><h2 id="值类型">值类型</h2><p>下面所列类型均可称为值类型，因为它们的变量总是值传递。即当作为方法参数或用作赋值时，总是值拷贝。</p><h3 id="booleans">布尔型</h3><p>布尔类型 <code>bool</code> ，其只可能有的值是常量 <code>true</code> 和 <code>false</code> 。</p><p>运算符有：</p><ul><li><strong>!</strong> ： 逻辑否</li><li><strong>&amp;&amp;</strong> ： 逻辑且(and)</li><li><strong>||</strong> ： 逻辑或(or)</li><li><strong>==</strong> ： 等于</li><li><strong>!=</strong> ： 不等于</li></ul><p><code>||</code> 和 <code>&amp;&amp;</code> 运算符常用短路求值(short-circuiting)策略。意思是在表达式 <code>f(x) || g(y)</code> 中，如果 <code>f(x)</code> 运算结果是 <code>true</code> ，则 <code>g(y)</code> 不会被运算，哪怕它有副作用。</p><div class="admonition quote"><p class="admonition-title">Wiki</p><p></p><p>短路求值（Short-circuit evaluation，又称最小化求值），是一种逻辑运算符的求值策略。只有当第一个运算数的值无法确定逻辑运算的结果时，才对第二个运算数进行求值。例如，当 AND 的第一个运算数的值为 false 时，其结果必定为 false ；当 OR 的第一个运算数为 true 时，最后结果必定为 true ，在这种情况下，就不需要知道第二个运算数的具体值。在一些语言中（如Lisp），默认的逻辑运算符就是短路运算符，而在另一些语言中（如 Java，Ada ），短路和非短路的运算符都存在。对于一些逻辑运算，如 XOR，短路求值是不可能的 。</p><p>短路表达式<code>x AND y</code>，事实上等价于条件语句：<code>if x then y else false</code>。短路表达式<code>x OR y</code>，则等价于条件语句：<code>if x then true else y</code>。</p><p></p></div><h3 id="integers">整数型</h3><p>整数类型分有符号<code>int</code>和无符号<code>uint</code>各种不同位大小的整数，从 <code>uint8</code> 到 <code>uint256</code> 有 8 个（无符号 8 到 256 位），还有 <code>int8</code> 到 <code>int256</code> 。 <code>uint</code> 和 <code>int</code> 分别是 <code>uint256</code> 和 <code>int256</code> 的别名。</p><p>运算操作有：</p><ul><li>比较运算： <code>&lt;=</code> 、 <code>&lt;</code> 、 <code>==</code> 、 <code>!=</code> 、 <code>&gt;=</code> 、 <code>&gt;</code> (结果为 <code>bool</code> )</li><li>位运算： <code>&amp;</code> 、 <code>|</code> 、 <code>^</code> (按位异或)、 <code>~</code> (按位取反)、<code>&lt;&lt;</code> （左移）、 <code>&gt;&gt;</code> （右移）</li><li>算术运算： <code>+</code> 、 <code>-</code> 、一元 <code>-</code>和<code>+</code> 、 <code>*</code> 、 <code>/</code> 、 <code>%</code> (取余)、 <code>**</code> (幂)</li></ul><p>整数相除总是截断取整的（它只被编译到 EVM 的 <code>DIV</code>操作码），但如果两个数都是有小数（或是小数表达式）时则不会截断。</p><p>除以零和零取模会抛出运行时异常。</p><p>移位操作的结果是左操作数的类型。表达式 <code>x &lt;&lt; y</code> 相当于 <code>x * 2**y</code>。 <code>x &gt;&gt; y</code>相当于 <code>x / 2**y</code>。这意味着可延伸到负数的位移，位移一个负数金额会抛出运行时异常。</p><div class="admonition warning"><p class="admonition-title">负值右移</p><p></p><p>有符号整数类型的负值右移运算结果和其他编程语言运算结果是不一样的。</p><p>在 Solidity 中右移映射到除法，因此位移后的负值将趋向与零（被截断）。在其他编程语言中，右移负数形同相除再四舍五入（趋向负无穷大）。</p><p></p></div><h3 id="fixed-point-numbers">定点数</h3><div class="admonition bug"><p class="admonition-title">未完整支持</p><p>在 Solidity 中定点数尚未完整支持。能够定义它们，但不能被分配。</p></div><p>定点数有 <code>fixed</code> 或 <code>ufixed</code>，有符合和无符号定点数各有不同位长度数字。<code>ufixedMxN</code> 和 <code>fixedMxN</code>，这里 <code>M</code> 表示该类型所代表的数字位长度，<code>N</code> 表示有多少小数点可用。 <code>M</code> 必须是从 8 位到 256 位间且能被 8 整除。<code>N</code> 必须是 <code>0</code> 到 <code>80</code> 之间。还包括，<code>ufixed</code> 和 <code>fixed</code> 分别是 <code>ufixed128x19</code> 和 <code>fixed128x19</code> 的别名。</p><p>运算符：</p><ul><li>比较运算： <code>&lt;=</code>、<code>&lt;</code>、<code>==</code>、<code>!=</code>、<code>&gt;=</code>、<code>&gt;</code> (结果为布尔 bool )</li><li>算术元素：<code>+</code>、<code>-</code>、一元<code>-</code>和<code>+</code>、<code>*</code>、<code>、</code>%`（取余）</li></ul><div class="admonition tip"><p class="admonition-title">vs 浮点数</p><p>浮点数（在其他许多语言中的<code>float</code> 和 <code>double</code>，精度更高的 IEEE754 规范）和 定点数的主要区别是，前者是整数部分和小数部分的位长度是灵活的，而在后者中是严格界定的。通常，一般来说，在浮点数中，几乎整个空间都用来表示数字，而只有少量的位长定义了小数点的位置。</p></div><h3 id="address">地址</h3><p>地址 <code>address</code> 是保存 20 个字节的值（以太坊账户地址长度）。地址类型也有成员，是所有合约的基础。</p><p>运算符： + <code>&lt;=</code>、<code>&lt;</code>、<code>==</code>、<code>!=</code>、<code>&gt;=</code>和<code>&gt;</code></p><div class="admonition info"><p class="admonition-title">Info</p><p>从 0.5.0 版本开始，合约不是从地址类型派生的，但仍然可以明确地将合约转换为地址。</p></div><h3 id="member-of-address">地址成员</h3><ul><li><strong>余额 <code>balance</code> 和 转账 (<code>transfer</code>)</strong></li></ul><p>详见 <a href="http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#address-related">Address Related</a>。是可以使用属性 <code>balance</code> 查询地址余额的，且可使用 <code>transfer</code> 方法发送 Ether(以 wei 为单位)到一个账户：</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kt">address</span> <span class="n">x</span> <span class="o">=</span> <span class="mh">0x123</span><span class="p">;</span>
<span class="kt">address</span> <span class="n">myAddress</span> <span class="o">=</span> <span class="nb">this</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nb">balance</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">myAddress</span><span class="p">.</span><span class="nb">balance</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="n">x</span><span class="p">.</span><span class="nb">transfer</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</code></pre></div><div class="admonition info"><p class="admonition-title">Info</p><p>如果 <code>x</code> 是合约地址，它的代码（更确切的说：它的回退方法，如果有）将被和 <code>transfer</code> 调用一起执行（这是 EVM 的一个特性，不能被绕开）。如果执行 gas 耗尽或者任何方式的失败，这 Ether 转账将被恢复（注：即回退交易），且合约终止执行。</p></div><ul><li><strong>发送 (<code>send</code>)</strong></li></ul><p>发送是转账的低级副本，如果执行失败，当前合约不会停止，但 <code>send</code> 将返回 <code>false</code>。</p><div class="admonition warning"><p class="admonition-title">Warning</p><p>使用 <code>send</code> 是有些危险的，如果执行堆栈深度到了 1024 （caller 强制限制） 则交易失败。同样 gas 耗尽也会失败。所以为了让转账安全，应总检查 <code>send</code> 返回值。 使用 <code>transfer</code> 也许更好：相当于一种收款人取款的模式。</p></div><ul><li><strong>调用(call)</strong>、<strong>callcode</strong>、<strong>委托调用(delegatecall)</strong></li></ul><p>此外，不遵循 ABI 合约接口，函数 <code>call</code> 支持任意类型的任意数量的参数。这些参数被填充到 32 字节并连接起来。一个例外是，第一个参数总会被编码为四个字节。在此情况下，不允许使用函数签名来填充。</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kt">address</span> <span class="n">nameReg</span> <span class="o">=</span> <span class="mh">0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2</span><span class="p">;</span>
<span class="n">nameReg</span><span class="p">.</span><span class="nb">call</span><span class="p">(</span><span class="s">&quot;register&quot;</span><span class="p">,</span> <span class="s">&quot;MyName&quot;</span><span class="p">);</span>
<span class="n">nameReg</span><span class="p">.</span><span class="nb">call</span><span class="p">(</span><span class="kt">bytes4</span><span class="p">(</span><span class="nf">keccak256</span><span class="p">(</span><span class="s">&quot;fun(uint256)&quot;</span><span class="p">)),</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div><p><code>call</code> 返回一个布尔值，来表明是否被调用方法被终止(true)还是引发了 EVM 异常 (false)。是无法访问调用返回的实际数据（这得需要我们事先知道函数返回值的编码和大小）。</p><p>可以用 <code>.gas()</code> 修改符来调整所供给的 gas :</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="n">namReg</span><span class="p">.</span><span class="nb">call</span><span class="p">.</span><span class="nb">gas</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)(</span><span class="s">&quot;register&quot;</span><span class="p">,</span> <span class="s">&quot;MyName&quot;</span><span class="p">);</span>
</code></pre></div><p>同样也可调整以太币 value：</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="n">namReg</span><span class="p">.</span><span class="nb">call</span><span class="p">.</span><span class="nb">value</span><span class="p">(</span><span class="mi">1</span> <span class="kc">ether</span><span class="p">)(</span><span class="s">&quot;register&quot;</span><span class="p">,</span> <span class="s">&quot;MyName&quot;</span><span class="p">);</span>
</code></pre></div><p>最后这些修改符可以连接在一起，顺序无关紧要：</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="n">nameReg</span><span class="p">.</span><span class="nb">call</span><span class="p">.</span><span class="nb">gas</span><span class="p">(</span><span class="mi">1000000</span><span class="p">).</span><span class="nb">value</span><span class="p">(</span><span class="mi">1</span> <span class="kc">ether</span><span class="p">)(</span><span class="s">&quot;register&quot;</span><span class="p">,</span> <span class="s">&quot;MyName&quot;</span><span class="p">);</span>
</code></pre></div><div class="admonition info"><p class="admonition-title">Info</p><p></p><p>在重载方法上是无法使用 gas 和 value 修改符的。</p><p>解决方案是引入一个 gas 和 value 特例，只需重新检查它们是否存在于重载分析点。</p><p></p></div><p>类似地，能使用 <code>delegatecall</code> 函数。区别在于只用给定地址的代码，所有其他内容（存储，余额）都从当前合约中获取。<code>delegatecall</code>的用意是使用存储在其他合约中的库代码。用户必须确保两个合同中的存储布局适合委托使用。从以太坊的 Prior 版 到 Homestead 版，只有一个名为 <code>callcode</code> 的有限变种可用，它不提供对原始 <code>msg.sender</code> 和 <code>msg.value</code> 值得访问。</p><p>这三个函数 <code>call</code>、<code>delegatecall</code> 和 <code>callcode</code> 是非常低级别功能，只能做为最后手段使用，因为他们打破了 Solidity 的类型安全性。</p><p><code>.gas()</code> 适用此三个方法，而已 <code>.value()</code>不支持 <code>delegatecall</code></p><div class="admonition tip"><p class="admonition-title">Tip</p><p>所有 contact 继承 address 成员，因此可以使用 <code>this.balance</code> 查询当前合约余额。</p></div><div class="admonition warning"><p class="admonition-title">Warning</p><p>不鼓励使用 <code>callcode</code> ，将在未来移除它。</p></div><div class="admonition warning"><p class="admonition-title">Warning</p><p>所有这些功能都是低级功能，应谨慎使用。具体而言，任何未知合约都可能是恶意的。如果你调用它，那么将把控制权移交给那个合约，然后再获得返回值到你的合约。以在调用返回时准备好更改状态变量。</p></div><h3 id="fixed-size-byte-arrays">定长字节数组</h3><p>固定长度有<code>bytes1</code>、<code>bytes2</code>、<code>bytes3</code>、&hellip;、<code>bytes32</code>，<code>byte</code> 是 <code>bytes1</code>别名。</p><p>运算符：</p><ul><li>比较运算：<code>&lt;=</code>、<code>&lt;</code>、<code>==</code>、<code>!=</code>、<code>&gt;=</code>、<code>&gt;</code> （结果为 <code>bool</code>）</li><li>位运算： <code>&amp;</code> 、 <code>|</code> 、 <code>^</code> (按位异或)、 <code>~</code> (按位取反)、<code>&lt;&lt;</code> （左移）、 <code>&gt;&gt;</code> （右移）</li><li>索引访问： 如果 <code>x</code> 是 <code>bytesI</code> 类型，则 <code>x[k]</code>（0&lt;= k &lt;= I）返回第 <code>k</code> 个字节（只读）。</li></ul><p>位移运算符使用任何整数类型作为右操作数（但将返回左操作数的类型），这表示要移位的位数。位移负数将导致运行时异常。</p><h4 id="成员">成员</h4><ul><li><code>length</code> 字段返回字节数组的固定长度（只读）。</li></ul><div class="admonition tip"><p class="admonition-title">Tip</p><p>可以使用字节数组作为 <code>byte[]</code>，但当调用传参时，每个元素占用 31 个字节，它浪费了很多空间。最好使用 <code>bytes</code>。</p></div><h3 id="dynamically-sized-byte-array">可变字节数组</h3><blockquote><p>注：英文为：dynamically-sized byte array ，直译为动态字节数组。觉得非常别扭，因此这里翻译为：可变字节数组。</p></blockquote><p><strong>bytes</strong>：可变字节字节数组，见<a href="#array">数组</a>，非值类型！</p><p><strong>string</strong>：可变字节的 UTF-8 编码字符串，见<a href="#array">数组</a>，非值类型！</p><p>根据经验，任意长度的原始 byte 数据使用 <code>bytes</code>，任意长途的字符串(UTF-8)数据使用<code>string</code>。如果你能限制字节长度到一定数量，优先使用 <code>bytes1</code> 到 <code>bytes32</code>，因为它们便宜得多。</p><h3 id="address-literals">地址字面量</h3><p>通过地址类型校验的十六进制字面量，例如 <code>0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</code> 是一个 <code>address</code> 类型。长度在39到41位之间的十六进制字面值，校验不通过会产生警告，并被视为常规的有理数字面值。</p><div class="admonition tip"><p class="admonition-title">Tip</p><p><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md">EIP-55</a> 定义了混合大小写的地址校验格式。</p></div><h3 id="rational-and-integer-literals">有理数和整数字面量</h3><p>整数字面量由 0 到 9 范围内的一系列数字组成，被视作十进制数。例如 <code>69</code> 即六十九。在 Solidity 中不存在八进制字面量，且高位零 (leading zeros)是无效的。 十进制小数字面量由 一个 <code>.</code> 组成，至少一边有数。例如：<code>1.</code>，<code>.1</code>，<code>1.3</code>。 也支持科学记数法，基数可以有小数，而指数不能。例如：<code>2e10</code>，<code>-2e10</code>，<code>2e-10</code>，<code>2.5e1</code>。</p><p>即使中间量不适应机器字长，可<code>(2**800 + 1) - 2**800</code> 返回常量 <code>1</code>（类型为 <code>uint8</code>）。此外，<code>.5 * 8</code> 返回整数<code>4</code>（虽然之间使用了非整数）。</p><p>只要操作数是整数，任何操作整数的运算符也可以使用于数字字面量表达式中。如果两者中的任何一个是小数，则不允许位操作。如果指数是小数（因为这可能导致非有理数），则不能取幂。</p><div class="admonition tip"><p class="admonition-title">Tip</p><p>每个有理数都有一个数字字面量类型。整数字面量和有理数字面量均属于数字字面量类型。此外，所有数字字面量表达式（即仅包含数字字面量和运算符的表达式）属于数字字面量类型。所以数字字面量表达式 <code>1 + 2</code> 和 <code>2 + 1</code> 对于有理数 3 都属于相同的数字字面量类型。</p></div><div class="admonition warning"><p class="admonition-title">除法结果</p><p>在早期版本中，数字字面量除法是截断的，但现在将转换为<strong>有理数</strong>，即 <code>5/2</code> 不等于 <code>2</code>，而是等于 <code>2.5</code>。</p></div><div class="admonition tip"><p class="admonition-title">Tip</p><p></p><p>数字字面量表达式只要与非字面量表达式一起使用，就会转换为非字面量类型。尽管知道下面示例中赋值给 <code>b</code> 的表达式值计算结果为一个整数 4，但是表达式 <code>2.5 + a</code> 没通过类型检查，所以编译失败。</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kt">uint128</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">uint128</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">.</span><span class="mi">5</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
</code></pre></div><div class="codehilite"><pre><code class="language-text" data-lang="text"><span></span>TypeError: Operator + not compatible with types rational_const 5/2 and uint128

uint128 b = 2.5 + a + 0.5;
            ^-----^
</code></pre></div><p></p></div><h3 id="string-literal">字符串字面量</h3><p>字符串字面量用双引号或单引号括起来（<code>&quot;foo&quot;</code>或<code>'bar'</code>）。与C语言字符串包含结束符不同，<code>&quot;foo&quot;</code>代表三个字节而非四个。与整数字面量一样，他们类型可变化。可隐式转换为 <code>bytes1</code>，&hellip;&hellip; <code>bytes32</code>，大小合适可转换为 <code>bytes</code> 和 <code>string</code>。</p><p>字符串字面量支持转义字符，如<code>\n</code>、<code>\xNN</code>和<code>\uNNNN</code>。其中<code>\xNN</code>取十六进制值并插入大小合适字节，而 <code>\uNNNN</code> 采用 Unicode 码点值，插入一个 UTF-8 序列。</p><h3 id="Hexadecimal-liternal">十六进制字面量</h3><p>十六进制字面量带有前缀 <code>hex</code> 关键字，并用双引号或单引号括起来(<code>hex&quot;001122FF&quot;</code>)。 其内容必须是一个十六进制字符串，其值将用二进制表示。 十六进制字面量行为像字符串字面量，并具有相同的可转换性限制。</p><h3 id="enum">枚举</h3><p>枚举是在 Solidity 中创建用户自定义类型的一种方法。可显式地与整数类型互转，但是不允许隐式转换。 显式转换会在运行时检查值范围，失败会导致异常。</p><p>枚举至少需要含一个成员。</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">test</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="n">ActionChoices</span> <span class="p">{</span> <span class="n">GoLeft</span><span class="p">,</span> <span class="n">GoRight</span><span class="p">,</span> <span class="n">GoStraight</span><span class="p">,</span> <span class="n">SitStill</span> <span class="p">}</span>
    <span class="n">ActionChoices</span> <span class="n">choice</span><span class="p">;</span>
    <span class="n">ActionChoices</span> <span class="kr">constant</span> <span class="n">defaultChoice</span> <span class="o">=</span> <span class="n">ActionChoices</span><span class="p">.</span><span class="n">GoStraight</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">setGoStraight</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="n">choice</span> <span class="o">=</span> <span class="n">ActionChoices</span><span class="p">.</span><span class="n">GoStraight</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//因为枚举类型不属于 ABI ，因此对函数 &quot;getChoice&quot; 签名将自动</span>
    <span class="c1">//变成对 &quot;getChoice() returns (uint8)&quot; 的签名。</span>
    <span class="c1">//在 Soldity 中对于外部处理，返回的整数类型是满足枚举值得最小尺寸。</span>
    <span class="c1">//即如果枚举值够大，将被使用 `uint16`。</span>
    <span class="kd">function</span> <span class="n">getChoice</span><span class="p">()</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span> <span class="p">(</span><span class="n">ActionChoices</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">choice</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">getDefaultChoice</span><span class="p">()</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">uint</span><span class="p">(</span><span class="n">defaultChoice</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="function-type">函数类型</h3><p>函数类型是函数的类型，函数类型的变量可以由函数赋值，函数类型的入参可以是函数，且函数调用可返回函数。 函数类型有两类：内部(internal)函数和外部(external)函数。</p><blockquote><p>注：这里有点儿拗口，即可理解为函数也是一种数据类型，可以像其他数据一样被定义、被当为函数入参和返回值。</p></blockquote><p>因为不能在当前合约上下文之外执行内部函数，内部函数只能在当前合约中调用（即在当前合约代码体中，还包括内部库函数和内部函数）。调用内部函数是通过跳到它的入口标签来实现的，就像在内部调用当前合同的函数一样。</p><p>外部函数由一个地址和一个函数签名组成，它们可以由外部函数调用或作为参数传递。</p><p>函数类型定义语法如下：</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kd">function</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">parameter</span> <span class="n">types</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span><span class="kr">internal</span><span class="o">|</span><span class="kr">external</span><span class="p">}</span> <span class="p">[</span><span class="kr">pure</span><span class="o">|</span><span class="kr">constant</span><span class="o">|</span><span class="kr">view</span><span class="o">|</span><span class="kr">payable</span><span class="p">]</span> <span class="p">[</span><span class="k">returns</span> <span class="p">(</span><span class="o">&lt;</span><span class="k">return</span> <span class="n">types</span><span class="o">&gt;</span><span class="p">)]</span>
</code></pre></div><p>与入参相反，返回值不能为空。 如果函数类型无返回值，则 <code>returns (&lt;return types&gt;)</code> 部分必须省去。</p><p>函数类型默认为内部函数，因此 关键字 <code>internal</code> 可省略。相反，合约函数本身默认是公开的，合约函数只有用作类型名时才默认是内部的。</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span> 
<span class="kd">contract</span> <span class="n">action</span> <span class="p">{</span>
    <span class="c1">// 定义变量 set，属于函数类型，无返回值。</span>
    <span class="kd">function</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="kr">internal</span>  <span class="n">set</span><span class="p">;</span>
    <span class="c1">// 定义变量 get ，属于函数类型，有返回值。</span>
    <span class="kd">function</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="kr">internal</span> <span class="k">returns</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span>   <span class="n">get</span><span class="p">;</span>  
<span class="p">}</span>
</code></pre></div><p>在当前合约中有两种方式访问函数，直接用名称<code>f</code>或用<code>this.f</code>。前者将按内部函数处理，后者按外部函数处理。</p><p>如果一个函数类型变量尚未初始化，调用时将引起异常。同样地，在调用 <code>delete</code> 后调用函数也会引起异常。</p><p>如果在 Solidity 上下文外部使用外部函数类型，则将它们视为函数类型，将地址连接函数前面一起编码为单个 bytes24 字节。</p><p>注意，当前合约的公共函数可作为内部和外部函数使用。仅用<code>f</code>，则公共函数 <code>f</code> 当做内部函数使用，如果你想使用它的外部形式，则用<code>this.f</code>。</p><p>另外，公共（或外部）函数都有一个特殊的成员 <code>selector</code>，返回 <a href="http://solidity.readthedocs.io/en/latest/abi-spec.html#abi-function-selector">ABI函数 selector</a></p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Selector</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes4</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">this</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="nb">selector</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>使用内部函数类型的示例：</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="c1">// 库</span>
<span class="kd">library</span> <span class="n">ArrayUtils</span> <span class="p">{</span>
  <span class="c1">// 因为在同一个合约代码上下文中，内部函数可作为内部库函数。 </span>
  <span class="kd">function</span> <span class="n">map</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">self</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="n">f</span><span class="p">)</span> <span class="kr">internal</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">r</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 创建同样长度的 uint 数组</span>
    <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[](</span><span class="n">self</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
    <span class="c1">// 遍历 self 数组元素，将元素值通过调用方法 `f` 后存入数组 r。</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">self</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="n">reduce</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">self</span><span class="p">,</span><span class="kd">function</span> <span class="p">(</span><span class="kt">uint</span><span class="p">,</span> <span class="kt">uint</span><span class="p">)</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="n">f</span><span class="p">)</span> <span class="kr">internal</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">r</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">self</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">r</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">self</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="n">range</span><span class="p">(</span><span class="kt">uint</span> <span class="n">length</span><span class="p">)</span> <span class="kr">internal</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[](</span><span class="n">length</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">Pyramid</span> <span class="p">{</span>
  <span class="c1">// 引入库函数</span>
  <span class="kn">using</span> <span class="n">ArrayUtils</span> <span class="k">for</span> <span class="o">*</span><span class="p">;</span>
  <span class="kd">function</span> <span class="n">pyramid</span><span class="p">(</span><span class="kt">uint</span> <span class="n">l</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 初始化一个 uint[] 数组，长度为 l，值为 0....l-1</span>
    <span class="c1">// 再进行使用map(square)加工使得值求平方，</span>
    <span class="c1">// 最后reduce(sum)获得累计求和值。</span>
    <span class="k">return</span> <span class="n">ArrayUtils</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="n">l</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="n">square</span><span class="p">).</span><span class="n">reduce</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="n">square</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">)</span> <span class="kr">internal</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="n">sum</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y</span><span class="p">)</span> <span class="kr">internal</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>另外一个使用外部函数类型的示例：</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Oracle</span> <span class="p">{</span>
  <span class="kd">struct</span> <span class="n">Request</span> <span class="p">{</span>
    <span class="kt">bytes</span> <span class="n">data</span><span class="p">;</span>
    <span class="c1">// 外部函数类型的字段</span>
    <span class="kd">function</span><span class="p">(</span><span class="kt">bytes</span> <span class="kr">memory</span><span class="p">)</span> <span class="kr">external</span> <span class="n">callback</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Request</span><span class="p">[]</span> <span class="n">requests</span><span class="p">;</span>
  <span class="kd">event</span> <span class="n">NewRequest</span><span class="p">(</span><span class="kt">uint</span><span class="p">);</span>
  <span class="c1">// external 标记外外部函数</span>
  <span class="kd">function</span> <span class="n">query</span><span class="p">(</span><span class="kt">bytes</span> <span class="n">data</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="kt">bytes</span> <span class="kr">memory</span><span class="p">)</span> <span class="kr">external</span> <span class="n">callback</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
    <span class="n">requests</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Request</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">callback</span><span class="p">));</span>
    <span class="n">NewRequest</span><span class="p">(</span><span class="n">requests</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="n">reply</span><span class="p">(</span><span class="kt">uint</span> <span class="n">requestID</span><span class="p">,</span> <span class="kt">bytes</span> <span class="n">response</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
    <span class="c1">// 检查 replay 来源可信源</span>
    <span class="n">requests</span><span class="p">[</span><span class="n">requestID</span><span class="p">].</span><span class="n">callback</span><span class="p">(</span><span class="n">response</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">OracleUser</span> <span class="p">{</span>
  <span class="n">Oracle</span> <span class="kr">constant</span> <span class="n">oracle</span> <span class="o">=</span> <span class="n">Oracle</span><span class="p">(</span><span class="mh">0x1234567</span><span class="p">);</span> <span class="c1">// 已知合约</span>
  <span class="kd">function</span> <span class="n">buySomething</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">oracle</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="s">&quot;USD&quot;</span><span class="p">,</span> <span class="nb">this</span><span class="p">.</span><span class="n">oracleResponse</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="n">oracleResponse</span><span class="p">(</span><span class="kt">bytes</span> <span class="n">response</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
    <span class="nb">require</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nb">sender</span> <span class="o">==</span> <span class="kt">address</span><span class="p">(</span><span class="n">oracle</span><span class="p">));</span>
    <span class="c1">// 使用数据</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><div class="admonition info"><p class="admonition-title">Info</p><p>Lambda 表达式和内联函数已计划但尚未支持。</p></div><h2 id="reference-types">引用类型</h2><p>复杂类型，即不能总是适合 256 位的类型，因为拷贝它们十分昂贵，必须比上面的值类型更仔细地处理。且我们必须得考虑是否要将它们存储在内存中（非持久）还是存储器（状态变量保持）中。</p><h3 id="data-location">数据位置</h3><p>每一种复杂类型，即数组和结构，都有一个额外的批注，即“数据位置（data location）”，标记它是存储在内存 memory 还是存储器 storage 中。根据上下文总有一个默认值，但是可以通过在类型中添加<code>storage</code>或<code>memory</code> 修饰符来覆盖默认值。函数参数（包括返回参数）默认数据位置在内存中，局部变量默认在存储器中，而状态变量位置被强制在存储器中（显然）。</p><p>还有第三个数据位置 <code>calldata</code> ，它是存储函数参数的一个不可修改的非持久性区域。外部函数的函数入参（不是出参）被强制存储在 <code>calldata</code>，其行为主要与内存相似。</p><p>数据位置非常重要，因为它们会改变存储分配的行为：存储器与内存之间的分配以及状态变量（甚至是来自其他状态变量）的分配始终会创建一个独立的副本。对局部变量的赋值只能指定一个引用，并且引用总是指向状态变量，即使后者期间被更改。另一方面，从内存存储的引用类型到另一个内存存储的引用类型的分配不会创建副本。</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kt">uint</span><span class="p">[]</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// x 存储在存储器中</span>

    <span class="c1">// memoryArray 在内存中</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="n">memoryArray</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">memoryArray</span><span class="p">;</span> <span class="c1">// 正常，复制整个数组到存储器</span>
        <span class="kd">var</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 正常，分配指针，y 存储在存储器中</span>
        <span class="n">y</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span> <span class="c1">// 返回第八个元素</span>
        <span class="n">y</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 通过 y 修改 x</span>
        <span class="k">delete</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 清空数组 x ，也会修改 y </span>
        
        <span class="c1">// 下面无法工作，它需要在存储中创建一个新的临时/无名数组。</span>
        <span class="c1">// 但是存储是静态分配的。</span>
        <span class="c1">// y = memoryArray;</span>


        <span class="c1">// 这也不正常，因为他将重置一个指针，可没有明显的位置可指向</span>
        <span class="c1">// delete y;</span>

        <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// 调用 g 函数，传递 x 指针 </span>
        <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// 调用 h 函数，在内存中创建一个独立的临时副本</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">g</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">storage</span> <span class="n">storageArray</span><span class="p">)</span> <span class="kr">internal</span> <span class="p">{}</span>
    <span class="kd">function</span> <span class="n">h</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="n">memoryArray</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><h4 id="小结">小结</h4><ul><li><p><strong>强制数据位置:</strong></p><ul><li>外部函数入参： calldata</li><li>状态变量： storage</li></ul></li><li><p><strong>默认数据位置:</strong></p><ul><li>函数入参： memory</li><li>所有其他局部变量： storage<br></li></ul></li></ul><h3 id="array">数组</h3><p>数组可以有一个编译期固定的大小，也可以是动态的。对于存储型数组（ storage arrays），元素类型可以是任意的（如其他数组，映射或结构）。对于内存型数组（memory arrays），元素类型不能是<a href="#mapping">映射类型</a> 。如果它是一个公共可见函数的参数，则元素类型必须是一个 ABI 类型。</p><p>一个固定大小 <code>k</code> 和元素类型 <code>T</code> 的数组可写成 <code>T[k]</code>。动态大小的则写成<code>T[]</code>。例如，元素为动态 uint 数组的定长 5 的数组是<code>x uint[][5]</code>(（请注意，与其他一些语言相比，表示方式是颠倒的)。访问第三个动态数组的第二个 uint，可用 <code>x[2][1]</code> (索引是基于零的，并且访问与声明方式相反，即 <code>x[2]</code> 在类型中从右边降一维)</p><p>字节<code>bytes</code>和字符串<code>string</code>类型的变量是特殊数组。一个 <code>bytes</code> 与 <code>byte[]</code> 相似，但是紧紧包裹在calldata 中。<code>string</code>等价<code>bytes</code>，但不允许长度或索引访问(当前)。</p><p>因为比较便宜，所以 <code>bytes</code> 总是比 <code>byte[]</code> 更受欢迎。</p><div class="admonition info"><p class="admonition-title">Info</p><p>如果你想访问字符串<code>s</code>的字节形式，使用 <code>bytes(s).length</code> 或 <code>bytes(s)[7]='x'</code>。请记住，此时你访问的是 UTF-8 表示的码值，而不是单个字符！</p></div><p>可将数组标记为<code>public</code>，Solidity 会创建一个 <a href="http://solidity.readthedocs.io/en/latest/contracts.html#visibility-and-getters">getter</a>。数组索引将成为 getter 函数的入参。</p><h4 id="allocatiing-memory-arrays">分配内存型数组</h4><p>在内存中创建可变长度的数组可以使用 <code>new</code> 关键字来完成。与存储型数组不同，不能通过给成员<code>.length</code> 赋值来调整内存型数组大小。</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">len</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="p">{</span>
        <span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[](</span><span class="mi">7</span><span class="p">);</span>
        <span class="kt">bytes</span> <span class="kr">memory</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">bytes</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
        <span class="c1">// 这里，a.length 为7，b.length 为 len。</span>

        <span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="array-literanls-inline">数组字面量/内联数组</h4><p>数组字面量是作为表达式写入的数组，且不会立刻分配到一个变量。</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="p">{</span>
        <span class="n">g</span><span class="p">([</span><span class="kt">uint</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="n">g</span><span class="p">(</span><span class="kt">uint</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="n">_data</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>数组字面量的类型是固定大小的内存型数组，其元素类型是给定元素的公共类型。 数组<code>[1,2,3]</code>的类型是 <code>uint8[3] memory</code>，因为这三个常量元素类型均是<code>uint8</code>。 因而在示例中，我们有必要将第一个元素转换为 <code>uint</code> 类型。注意，目前固定大小的内存型数组不能被分配给动态内存型数组，即以下是不可能的：</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="c1">// 无法编译。</span>

<span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// 类型错误，因为 uint[3] 数组不能被转换为 uint[]</span>
        <span class="kt">uint</span><span class="p">[]</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="kt">uint</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>计划在将来去除此限制，但是目前考虑数组在ABI中传输的情况，修改会产生一些复杂性。</p><h4 id="memeber">成员</h4><ul><li><strong>length</strong></li></ul><p>数组有一个长度成员来记录元素的数量。动态数组可以通过改变.length成员在存储器中（而不是在内存中）调整大小。当尝试访问当前长度之外的元素时，不会自动调整大小。存储型数组大小在创建之后是固定的（但是动态的，可以依赖运行时参数）。</p><ul><li><strong>push</strong><br></li></ul><p>动态存储型数组和 <code>bytes</code>（非<code>string</code>）有一个成员方法 <code>push</code>。可用于在数组末尾追加元素。函数返回数组新长度。</p><div class="admonition warning"><p class="admonition-title">Warning</p><p>无法在外部函数中使用元素类型是数组的数组。</p></div><div class="admonition tip"><p class="admonition-title">Tip</p><p></p><p>由于 EVM 的局限性，调用外部函数无法返回动态内容，在合约<code>contract C { function f() returns (uint[]) { ... } }</code>中，如果 web3.js 调用方法 <code>f</code> 将返回些内容，但从 Solidity 调用则没有。</p><p>现在唯一的解决方法是使用大型静态数组。</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">ArrayContract</span> <span class="p">{</span>
    <span class="kt">uint</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="mi">20</span><span class="p">]</span> <span class="n">m_aLotOfIntegers</span><span class="p">;</span>
    <span class="c1">// 注意，下面不是动态数组是元素，而是动态数组是元素（即，定长数组长度为2） </span>
    <span class="kt">bool</span><span class="p">[</span><span class="mi">2</span><span class="p">][]</span> <span class="n">m_pairsOfFlags</span><span class="p">;</span>
   
    <span class="c1">// newPairs 存储在内存中 ———— 默认的函数入参 </span>
    <span class="kd">function</span> <span class="n">setAllFlagPairs</span><span class="p">(</span><span class="kt">bool</span><span class="p">[</span><span class="mi">2</span><span class="p">][]</span> <span class="n">newPairs</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span> 
        <span class="c1">// 分配一个存储型数组替换此完整数组</span>
        <span class="n">m_pairsOfFlags</span> <span class="o">=</span> <span class="n">newPairs</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">setFlagPair</span><span class="p">(</span><span class="kt">uint</span> <span class="n">index</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flagA</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flagB</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// 访问不存在的索引，将抛异常</span>
        <span class="n">m_pairsOfFlags</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">flagA</span><span class="p">;</span>
        <span class="n">m_pairsOfFlags</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">flagB</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">changeFlagArraySize</span><span class="p">(</span><span class="kt">uint</span> <span class="n">newSize</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// 如果新长度过小，则将移除末尾元素</span>
        <span class="n">m_pairsOfFlags</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">newSize</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">clear</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// 这些完全清除数组</span>
        <span class="k">delete</span> <span class="n">m_pairsOfFlags</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">m_aLotOfIntegers</span><span class="p">;</span>
        <span class="c1">// 效果与上相同</span>
        <span class="n">m_pairsOfFlags</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bytes</span> <span class="n">m_byteData</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">byteArrays</span><span class="p">(</span><span class="kt">bytes</span> <span class="n">data</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="c1">// 字节数组 (&quot;bytes&quot;) 是不同的，因为他们没有追加存储。</span>
        <span class="c1">// 但可以背视为同等的 &quot;uint8p[]&quot;</span>
        <span class="n">m_byteData</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
        <span class="n">m_byteData</span><span class="p">.</span><span class="n">length</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">;</span>
        <span class="n">m_byteData</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="kt">byte</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
        <span class="k">delete</span> <span class="n">m_byteData</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">addFlag</span><span class="p">(</span><span class="kt">bool</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">flag</span><span class="p">)</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_pairsOfFlags</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">flag</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">createMemoryArray</span><span class="p">(</span><span class="kt">uint</span> <span class="n">size</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 用 `new` 创建的动态内心型数组 </span>
        <span class="kt">uint</span><span class="p">[</span><span class="mi">2</span><span class="p">][]</span> <span class="kr">memory</span> <span class="n">arrayOfPairs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[</span><span class="mi">2</span><span class="p">][](</span><span class="n">size</span><span class="p">);</span>
        <span class="c1">// 创建动态 bytes 数组</span>
        <span class="kt">bytes</span> <span class="kr">memory</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">bytes</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kt">byte</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p></p></div><h3 id="stucts">结构</h3><p>Solidity 提供一种以结构（structs）形式定义新类型的方法。在下示例中展示：</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>

<span class="c1">// 众筹合约</span>
<span class="kd">contract</span> <span class="n">CrowdFunding</span> <span class="p">{</span>
    <span class="c1">// 定义新类型，有两个字段</span>
    <span class="kd">struct</span> <span class="n">Funder</span> <span class="p">{</span>
        <span class="kt">address</span> <span class="n">addr</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="n">amount</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">struct</span> <span class="n">Campaign</span> <span class="p">{</span>
        <span class="kt">address</span> <span class="n">beneficiary</span><span class="p">;</span> <span class="c1">//发起者，受益人</span>
        <span class="kt">uint</span> <span class="n">fundingGoal</span><span class="p">;</span><span class="c1">//目标额</span>
        <span class="kt">uint</span> <span class="n">numFunders</span><span class="p">;</span><span class="c1">//支持者人数</span>
        <span class="kt">uint</span> <span class="n">amount</span><span class="p">;</span> <span class="c1">// 累计募集资金</span>
        <span class="kd">mapping</span> <span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="n">Funder</span><span class="p">)</span> <span class="n">funders</span><span class="p">;</span><span class="c1">//支持者具体信息</span>
    <span class="p">}</span>

    <span class="kt">uint</span> <span class="n">numCampaigns</span><span class="p">;</span>
    <span class="kd">mapping</span> <span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="n">Campaign</span><span class="p">)</span> <span class="n">campaigns</span><span class="p">;</span>

    <span class="c1">// 新建众筹项，指定受益人和目标数</span>
    <span class="kd">function</span> <span class="n">newCampaign</span><span class="p">(</span><span class="kt">address</span> <span class="n">beneficiary</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">goal</span><span class="p">)</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">campaignID</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ID 递增，并存储众筹项</span>

        <span class="n">campaignID</span> <span class="o">=</span> <span class="n">numCampaigns</span><span class="o">++</span><span class="p">;</span> <span class="c1">// campaignID  是函数返回变量 </span>
        <span class="c1">// 创建新的结构，并保存在存储中。忽略 mapping 类型</span>
        <span class="n">campaigns</span><span class="p">[</span><span class="n">campaignID</span><span class="p">]</span> <span class="o">=</span> <span class="n">Campaign</span><span class="p">(</span><span class="n">beneficiary</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 支持项目，将保存支持者信息(地址与捐赠额)</span>
    <span class="kd">function</span> <span class="n">contribute</span><span class="p">(</span><span class="kt">uint</span> <span class="n">campaignID</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">payable</span> <span class="p">{</span>
        <span class="n">Campaign</span> <span class="kr">storage</span> <span class="n">c</span> <span class="o">=</span> <span class="n">campaigns</span><span class="p">[</span><span class="n">campaignID</span><span class="p">];</span>
        <span class="c1">// 创建一个临时内存结构变量，用给定值初始化，并复制到存储器。</span>
        <span class="c1">// 注意，也可以使用 Funder(msg.sender, msg.value) 初始化。</span>
        <span class="n">c</span><span class="p">.</span><span class="n">funders</span><span class="p">[</span><span class="n">c</span><span class="p">.</span><span class="n">numFunders</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">Funder</span><span class="p">({</span><span class="n">addr</span><span class="o">:</span> <span class="nb">msg</span><span class="p">.</span><span class="nb">sender</span><span class="p">,</span> <span class="n">amount</span><span class="o">:</span> <span class="nb">msg</span><span class="p">.</span><span class="nb">value</span><span class="p">});</span>
        <span class="n">c</span><span class="p">.</span><span class="n">amount</span> <span class="o">+=</span> <span class="nb">msg</span><span class="p">.</span><span class="nb">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 检查众筹项是否到达预期目标并将资金移交给受益人</span>
    <span class="kd">function</span> <span class="n">checkGoalReached</span><span class="p">(</span><span class="kt">uint</span> <span class="n">campaignID</span><span class="p">)</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">reached</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Campaign</span> <span class="kr">storage</span> <span class="n">c</span> <span class="o">=</span> <span class="n">campaigns</span><span class="p">[</span><span class="n">campaignID</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">amount</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">fundingGoal</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="n">amount</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">amount</span><span class="p">;</span>
        <span class="n">c</span><span class="p">.</span><span class="n">amount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">c</span><span class="p">.</span><span class="n">beneficiary</span><span class="p">.</span><span class="nb">transfer</span><span class="p">(</span><span class="n">amount</span><span class="p">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>上面合约没有提供众筹合约的全部功能，但它包含了理解结构所必需的基本概念。结构类型可以用在映射和数组中，它们本身可以包含映射和数组。</p><p>尽管结构本身可以映射成员的值类型，但结构成员不可能是自身类型。这个限制是必须的，因为必须限制结构大小。</p><p>请注意，在所有函数中，结构分配给局部变量（默认数据位置：存储器），这不会拷贝该结构。而只会指向一个引用，以便局部变量可写入状态中。</p><p>当然，你也可以直接访问结构的成员，而不必将其分配给局部变量。如：<code>campaigns[campaignID].amount = 0</code></p><h2 id="mapping">映射</h2><p>用 <code>mapping(_KeyType =&gt; _ValueType)</code> 声明映射类型。这里 <code>_KeyType</code> 几乎可以是任何类型，除映射类型外，可以是动态数组，合约，枚举和结构。<code>_ValueType</code> 实际上可以是任何类型，包括映射类型。</p><p>映射类型可以看作<a href="https://en.wikipedia.org/wiki/Hash_table">哈希表</a>，这哈希表被虚拟初始化，使得每个可能的 key 都存在并被映射到其字节表示全部为零的值：类型的默认值。但相似性也就只有这些。key 数据实际上并不存储在映射中，只用它的 <code>keccak256</code>哈希用来查找值。</p><p>映射只能用于状态变量（或作为内部函数中的存储引用类型）。</p><p>可以标记映射类型为<code>public</code>，Solidity 会创建一个 <a href="http://solidity.readthedocs.io/en/latest/contracts.html#visibility-and-getters">getter</a>。<code>_KeyType</code> 将成为 getter 入参，它将返回<code>_ValueType</code>。</p><p><code>_ValueType</code> 也可以是映射类型，getter 函数将为每个 <code>_KeyType</code> 递归地提供一个参数。</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">MappingExample</span> <span class="p">{</span>
    <span class="kd">mapping</span><span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="kt">uint</span><span class="p">)</span> <span class="kr">public</span> <span class="n">balances</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">update</span><span class="p">(</span><span class="kt">uint</span> <span class="n">newBalance</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="n">balances</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nb">sender</span><span class="p">]</span> <span class="o">=</span> <span class="n">newBalance</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">MappingUser</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">MappingExample</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MappingExample</span><span class="p">();</span>
        <span class="n">m</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">balances</span><span class="p">(</span><span class="nb">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><div class="admonition info"><p class="admonition-title">Info</p><p>不能迭代映射，但可以在其上实现一个数据结构，见 <a href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol">迭代 mapping</a> 示例。</p></div><h2 id="Operators Involving LValues">左值运算</h2><p>如果 <code>a</code> 是一个左值（即变量或一些东西可以分配给它。）以下操作符可简写：</p><p><code>a += e</code> 等同 <code>a = a + e</code>。相应的还有操作符 <code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>|=</code>、<code>&amp;=</code>和<code>^=</code>。 <code>a++</code> 和 <code>a--</code> 分别等同 <code>a += 1</code> 和 <code>a -= 1</code>，但此表达式的计算结果仍然是 a 的旧值。相反，<code>--a</code> 和 <code>++ a</code> 对 a 有相同效果，但是是在更改后再返回值（新值）。</p><h3 id="delete">delete</h3><p><code>delete a</code>将重置 a，并将类型的初始值赋给 a ，即对于整数它相当于 <code>a = 0</code>。它也可以用于数组，其中分配一个长度为零的动态数组或一个长度相同的静态数组，其中所有元素都被重置。对于结构体，它分配一个所有成员重置的结构体。</p><p><code>delete</code> 对整个映射没影响（因为映射的键可能是任意的且通常是未知的）。如果你删除一个结构体，所有非映射类型的成员将被重置。但是可以删除个别密钥及其映射的内容。</p><p>重要提醒，<code>delete a</code> 真实行为就向<code>a</code>赋值，即存储一个新对象到 <code>a</code>。</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">DeleteExample</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">uint</span><span class="p">[]</span> <span class="n">dataArray</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 设置 x 为 0，不影响 data  </span>
        <span class="k">delete</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// 设置 data 为 0，不会影响仍然拥有副本的 x。</span>
        <span class="kt">uint</span><span class="p">[]</span> <span class="kr">storage</span> <span class="n">y</span> <span class="o">=</span> <span class="n">dataArray</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">dataArray</span><span class="p">;</span> <span class="c1">// 设置 dataArray 长度为0</span>
        <span class="c1">//可 uint[] 作为复杂类型，y 作为存储对象的别名（引用）是受影响的。</span>
        <span class="c1">//另一方面 `delete y` 无效，作为局部变量的赋值，</span>
        <span class="c1">//只能从现有的存储对象中引用存储对象。 </span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="Conversions-between-Elementary-Types">基础类型的类型转换</h2><h3 id="Implicit-Conversions">隐式转换</h3><p>如果运算符应用于不同的类型，编译器会尝试隐式地将其中一个操作数转换为另一个的类型（对于赋值也是如此）。一般来说，如果语义上有合理且没有信息丢失，那么值类型之间的隐式转换是可能的：<code>uint8</code>可转换为<code>uint16</code>，<code>int128</code>可转换为<code>int256</code>，但是<code>int8</code>不转换成<code>uint256</code>（因为<code>uint256</code>不能全部容纳，例如<code>-1</code>）。此外，无符号整数可以转换为相同或更大的 bytes ，反之亦然。任何可以转换为<code>uint160</code>的类型也可以转换为<code>address</code>。</p><h3 id="Explicit-Conversions">显式转换</h3><p>如果编译器不允许隐式转换，但是你又清楚自己在做什么，则有时可以使用显式类型转换。注意，这可能会给你一些意想不到的行为，所以一定要测试，以确保结果是你想要的！把下面的例子转换成一个负<code>int8</code>为<code>uint</code>：</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kt">int8</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">;</span>
<span class="kt">uint</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">uint</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
</code></pre></div><p>在这个代码段末尾，<code>x</code>的值是<code>0xfffff..fd</code>（64个十六进制字符），在256位的二进制补码表示中是-3。</p><p>如果一个类型被显式地转换为一个较小的类型，那么高位被截断：</p><pre><code>uint32 a = 0x12345678;
uint16 b = uint16(a); // b 将是 0x5678
</code></pre><h2 id="Type-Deduction">类型推导</h2><p>为方便起见，并不总需要显式指定变量的类型，编译器会自动将其从赋值给变量的第一个表达式的类型中推断出来：</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kt">uint24</span> <span class="n">x</span> <span class="o">=</span> <span class="mh">0x123</span><span class="p">;</span>
<span class="kd">var</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</code></pre></div><p>这里 <code>y</code> 会是 <code>uint24</code> 类型，不能在函数入参或出参上使用 <code>var</code>。</p><div class="admonition warning"><p class="admonition-title">Warning</p><p>类型只是从第一个赋值中推导出来的，所以下面的代码段会是死循环。因为<code>i</code>是<code>uint8</code>类型，而此类型的最大值255小于<code>2000</code>。<code>for (var i = 0; i &lt; 2000; i++) { ... }</code></p></div><h2 id="__source">source</h2><div><a href="https://github.com/ysqi/etheraction/blob/master/content/solidity/doc/depth/types.md" title="github source file" class="md-source-file">types.md </a><a href="https://github.com/ysqi/etheraction/edit/master/content/solidity/doc/depth/types.md" title="github source file" class="md-source-file">editor source file</a></div></article></div></div></main><footer class="md-footer"><div class="md-footer-nav"><nav class="md-footer-nav__inner md-grid"><a href="http://ethereum.mochain.info/solidity/doc/depth/layout-of-source-files.html" title="源文件布局" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev"><div class="md-flex__cell md-flex__cell--shrink"><i class="md-icon md-icon--arrow-back md-footer-nav__button"></i></div><div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"><span class="md-flex__ellipsis"><span class="md-footer-nav__direction">previous</span> 源文件布局</span></div></a><a href="http://ethereum.mochain.info/solidity/doc/units-and-global-variables.html" title="单位和全局变量" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next"><div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"><span class="md-flex__ellipsis"><span class="md-footer-nav__direction">next</span> 单位和全局变量</span></div><div class="md-flex__cell md-flex__cell--shrink"><i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i></div></a></nav></div><div class="md-footer-meta md-typeset"><div class="md-footer-meta__inner md-grid"><div class="md-footer-copyright"><div class="md-footer-copyright__highlight">&copy; 2018 根据Apache 2.0 许可发布</div>powered by <a href="https://gohugo.io/" rel="nofollow">Hugo</a> and <a href="https://squidfunk.github.io/mkdocs-material/" rel="nofollow">Material for Hugo</a></div><div class="md-footer-social"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><a href="https://github.com/ysqi" class="md-footer-social__link fa fa-github"></a> <a href="https://yushuangqi.com" class="md-footer-social__link fa fa-wordpress"></a> <a href="https://weibo.com/234665601" class="md-footer-social__link fa fa-weibo"></a> <a href="https://www.zhihu.com/people/_ysqi/" class="md-footer-social__link fa fa-user-circle"></a> <a href="mailto:devysqi@gmail.com" class="md-footer-social__link fa fa-envelope-o"></a></div></div></div></footer></div><script>var base_url = '';
      var repo_id  = '';</script><script>var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");
      for(var i = 0; i < headers.length; i++) {
          var a = document.createElement("a");
          a.setAttribute("class", "headerlink");
          a.setAttribute("href", "#" + headers[i].id);
          a.setAttribute("title", "Permanent link")
          a.innerHTML = "¶";
          headers[i].appendChild(a);
      }</script><script src="http://ethereum.mochain.info/javascripts/application.js"></script><script>app.initialize({version:"0.17.2",url:{base:".."}})</script></body></html>