<!DOCTYPE html><html class="no-js" lang="zh-cn"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Soldity 汇编 - 精通以太坊</title><meta name="generator" content="Hugo 0.31.1"><meta name="description" content="solidity文档中文版章节《汇编》"><link rel="canonical" href="http://ethereum.mochain.info/solidity/doc/assembly.html"><meta name="author" content="虞双齐"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="32x32" href="http://ethereum.mochain.info/images/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="精通以太坊"><link rel="apple-touch-icon-precomposed" href="http://ethereum.mochain.info/images/app-icon64x64.png"><meta name="msapplication-TileImage" content="/images/app-icon128x128.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:url" content="http://ethereum.mochain.info/solidity/doc/assembly.html"><meta property="og:title" content="精通以太坊"><meta property="og:image" content="http://ethereum.mochain.info/images/logo.png"><meta name="apple-mobile-web-app-title" content="精通以太坊"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="lang:clipboard.copy" content="Copy to clipboard"><meta name="lang:clipboard.copied" content="Copied to clipboard"><meta name="lang:search.language" content="en"><meta name="lang:search.result.none" content="No matching documents"><meta name="lang:search.result.one" content="1 matching document"><meta name="lang:search.result.other" content="# matching documents"><meta name="lang:search.tokenizer" content="[\s\-]+"><link rel="shortcut icon" type="image/x-icon" href="http://ethereum.mochain.info/images/favicon.ico"><link rel="icon" type="image/x-icon" href="http://ethereum.mochain.info/images/favicon.ico"><style>@font-face{font-family:Icon;src:url(http://ethereum.mochain.info/fonts/icon.eot);src:url(http://ethereum.mochain.info/fonts/icon.eot) format('embedded-opentype'),url(http://ethereum.mochain.info/fonts/icon.woff) format('woff'),url(http://ethereum.mochain.info/fonts/icon.ttf) format('truetype'),url(http://ethereum.mochain.info/fonts/icon.svg) format('svg');font-weight:400;font-style:normal}</style><link rel="stylesheet" href="http://ethereum.mochain.info/stylesheets/application.css"><link rel="stylesheet" href="http://ethereum.mochain.info/stylesheets/palette.css"><link rel="stylesheet" href="//fonts.cat.net/css?family=Noto%20Sans%20CJK:400,700|Ubuntu&#43;Mono"><style>body,input{font-family:'Noto Sans CJK',Helvetica,Arial,sans-serif}code,pre{font-family:'Ubuntu Mono','Courier New',Courier,monospace}</style><link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons"><script src="http://ethereum.mochain.info/javascripts/modernizr.js"></script></head><body dir="ltr" data-md-color-primary="light-gren" data-md-color-accent="indigo"><svg class="md-svg"><defs><svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg></defs></svg> <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer"> <input class="md-toggle" data-md-toggle="search" type="checkbox" id="search"> <label class="md-overlay" data-md-component="overlay" for="drawer"></label> <a href="#getting-started" tabindex="1" class="md-skip">Skip to content</a><header class="md-header" data-md-component="header"><nav class="md-header-nav md-grid"><div class="md-flex"><div class="md-flex__cell md-flex__cell--shrink"><a href="http://ethereum.mochain.info" title="精通以太坊" class="md-header-nav__button md-logo"><i class="md-icon"></i></a></div><div class="md-flex__cell md-flex__cell--shrink"><label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label></div><div class="md-flex__cell md-flex__cell--stretch"><div class="md-flex__ellipsis md-header-nav__title" data-md-component="title"><span class="md-header-nav__topic">精通以太坊 </span><span class="md-header-nav__topic">Soldity 汇编</span></div></div><div class="md-flex__cell md-flex__cell--shrink"><label class="md-icon md-icon--search md-header-nav__button" for="search"></label></div><div class="md-flex__cell md-flex__cell--shrink"><div class="md-header-nav__source"><a href="https://github.com/ysqi/etheraction" title="Go to repository" class="md-source" data-md-source="github"><div class="md-source__icon"><svg viewBox="0 0 24 24" width="24" height="24"><use xlink:href="#github" width="24" height="24"></use></svg></div><div class="md-source__repository">ysqi/etheraction</div></a></div></div></div></nav></header><div class="md-container"><nav class="md-tabs md-tabs--active" data-md-component="tabs"><div class="md-tabs__inner md-grid"><ul class="md-tabs__list"><li class="md-tabs__item"><a href="http://ethereum.mochain.info/basic/" title="基础知识" class="md-tabs__link">基础知识</a></li><li class="md-tabs__item"><a href="http://ethereum.mochain.info/contract/" title="智能合约" class="md-tabs__link">智能合约</a></li><li class="md-tabs__item"><a href="http://ethereum.mochain.info/solidity/doc" title="Solidiy官方文档中文版" class="md-tabs__link md-tabs__link--active">Solidiy官方文档中文版</a></li><li class="md-tabs__item"><a href="http://ethereum.mochain.info/action" title="实战" class="md-tabs__link">实战</a></li><li class="md-tabs__item"><a href="http://ethereum.mochain.info/about" title="关于" class="md-tabs__link">关于</a></li></ul></div></nav><main class="md-main"><div class="md-main__inner md-grid" data-md-component="container"><div class="md-sidebar md-sidebar--primary" data-md-component="navigation"><div class="md-sidebar__scrollwrap"><div class="md-sidebar__inner"><nav class="md-nav md-nav--primary" data-md-level="0"><label class="md-nav__title md-nav__title--site" for="drawer"><span class="md-nav__button md-logo"><i class="md-icon"></i> </span>精通以太坊22</label><div class="md-nav__source"><a href="https://github.com/ysqi/etheraction" title="Go to repository" class="md-source" data-md-source="github"><div class="md-source__icon"><svg viewBox="0 0 24 24" width="24" height="24"><use xlink:href="#github" width="24" height="24"></use></svg></div><div class="md-source__repository">ysqi/etheraction</div></a></div><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-0" type="checkbox" id="nav-0"> <label class="md-nav__link" for="nav-0">基础知识</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-0">基础知识</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="http://ethereum.mochain.info/basic/" title="说明" class="md-nav__link">说明</a></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-0-1" type="checkbox" id="nav-0-1"> <label class="md-nav__link" for="nav-0-1">以太坊概念</label><nav class="md-nav" data-md-component="collapsible" data-md-level="2"><label class="md-nav__title" for="nav-0-1">以太坊概念</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="http://ethereum.mochain.info/basic/ethereum/gas.html" title="理解Gas" class="md-nav__link">理解Gas</a></li></ul></nav></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1"> <label class="md-nav__link" for="nav-1">智能合约</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-1">智能合约</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="http://ethereum.mochain.info/contract/" title="前言" class="md-nav__link">前言</a></li></ul></nav></li><li class="md-nav__item md-nav__item--active md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" checked="checked"> <label class="md-nav__link" for="nav-2">Solidiy官方文档中文版</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-2">Solidiy官方文档中文版</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/" title="简介" class="md-nav__link">简介</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/introduction-to-smart-contracts.html" title="智能合约介绍" class="md-nav__link">智能合约介绍</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/installing-solidity.html" title="安装 Solidity" class="md-nav__link">安装 Solidity</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/solidity-by-example.html" title="Solidity 示例" class="md-nav__link">Solidity 示例</a></li><li class="md-nav__item md-nav__item--active md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-4" type="checkbox" id="nav-2-4" checked="checked"> <label class="md-nav__link" for="nav-2-4">深入了解 Solidity</label><nav class="md-nav" data-md-component="collapsible" data-md-level="2"><label class="md-nav__title" for="nav-2-4">深入了解 Solidity</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/depth/layout-of-source-files.html" title="源文件布局" class="md-nav__link">源文件布局</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/depth/types.html" title="类型" class="md-nav__link">类型</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/units-and-global-variables.html" title="单位和全局变量" class="md-nav__link">单位和全局变量</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/control-structures.html" title="表达式与控制结构" class="md-nav__link">表达式与控制结构</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/solidity/doc/contracts.html" title="合约" class="md-nav__link">合约</a></li><li class="md-nav__item md-nav__item--active"><input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="toc"> <label class="md-nav__link md-nav__link--active" for="toc">Soldity 汇编</label> <a href="http://ethereum.mochain.info/solidity/doc/assembly.html" title="Soldity 汇编" class="md-nav__link md-nav__link--active">Soldity 汇编</a></li></ul></nav></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3"> <label class="md-nav__link" for="nav-3">实战</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-3">实战</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="http://ethereum.mochain.info/action/" title="实战" class="md-nav__link">实战</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/action/game/" title="以太碟游戏" class="md-nav__link">以太碟游戏</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/action/lottery/" title="快3彩票" class="md-nav__link">快3彩票</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/action/token/" title="五彩石代币" class="md-nav__link">五彩石代币</a></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4"> <label class="md-nav__link" for="nav-4">关于</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-4">关于</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="http://ethereum.mochain.info/about/" title="关于本书" class="md-nav__link">关于本书</a></li><li class="md-nav__item"><a href="http://ethereum.mochain.info/about/license.html" title="License" class="md-nav__link">License</a></li></ul></nav></li></ul></nav></div></div></div><div class="md-sidebar md-sidebar--secondary" data-md-component="toc"><div class="md-sidebar__scrollwrap"><div class="md-sidebar__inner"><nav class="md-nav md-nav--secondary"><h4 class="md-nav__title" for="toc">Table of Contents</h4><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="#inline-assembly" class="md-nav__link">内联汇编</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#%e7%a4%ba%e4%be%8b" class="md-nav__link">示例</a></li><li class="md-nav__item"><a href="#syntax" class="md-nav__link">语法</a></li><li class="md-nav__item"><a href="#%e6%93%8d%e4%bd%9c%e7%a0%81" class="md-nav__link">操作码</a></li><li class="md-nav__item"><a href="#Literals" class="md-nav__link">字面量</a></li><li class="md-nav__item"><a href="#Functional-Style" class="md-nav__link">函数式</a></li><li class="md-nav__item"><a href="#access-to-external-variables-and-functions" class="md-nav__link">Access to External Variables and Functions</a></li><li class="md-nav__item"><a href="#labels" class="md-nav__link">Labels</a></li><li class="md-nav__item"><a href="#declaring-assembly-local-variables" class="md-nav__link">Declaring Assembly-Local Variables</a></li><li class="md-nav__item"><a href="#assignments" class="md-nav__link">Assignments</a></li><li class="md-nav__item"><a href="#if" class="md-nav__link">If</a></li><li class="md-nav__item"><a href="#switch" class="md-nav__link">Switch</a></li><li class="md-nav__item"><a href="#loops" class="md-nav__link">Loops</a></li><li class="md-nav__item"><a href="#functions" class="md-nav__link">Functions</a></li><li class="md-nav__item"><a href="#things-to-avoid" class="md-nav__link">Things to Avoid</a></li><li class="md-nav__item"><a href="#conventions-in-solidity" class="md-nav__link">Conventions in Solidity</a></li></ul></nav></li><li class="md-nav__item"><a href="#standalone-assembly" class="md-nav__link">Standalone Assembly</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#parsing-grammar" class="md-nav__link">Parsing / Grammar</a></li><li class="md-nav__item"><a href="#desugaring" class="md-nav__link">Desugaring</a></li><li class="md-nav__item"><a href="#opcode-stream-generation" class="md-nav__link">Opcode Stream Generation</a></li></ul></nav></li></ul></nav></div></div></div><div class="md-content"><article class="md-content__inner md-typeset"><a href="https://github.com/ysqi/etheraction/edit/master/content/solidity/doc/assembly.md" title="" class="md-icon md-content__icon">&#xE3C9;</a><h1>Soldity 汇编</h1><p>Solidity 定义了一种汇编语言，可不用Solidity 下使用。也可在 Solidity 源代码中作为“内联汇编”使用。下面开始介绍怎么使用内联汇编和与独立汇编有何不同，并讲解其特殊性。</p><h2 id="inline-assembly">内联汇编</h2><p>在 Solidity 语句中交叉使用汇编，以更加接近虚拟机语言，可更细致控制，特别是为通过编写库来增强语言。因为实际上 EVM 为堆栈机，通常很难解决正确的堆栈插槽问题，并为堆栈上正确的操作码提供参数。 Solidity的内联汇编试图通过以下功能来简化手动汇编时出现的问题：</p><ul><li>函数式操作码：<code>mul(1, add(2, 3))</code>代替<code>push1 3 push1 2 add push1 1 mul</code>。</li><li>汇编局部变量：<code>let x := add(2, 3) let y := mload(0x40) x := add(x, y)</code>。</li><li>访问外部变量：<code>function f(uint x) public { assembly { x := sub(x, 1) } }</code>。</li><li>标签：<code>let x := 10 repeat: x := sub(x, 1) jumpi(repeat, eq(x, 0))</code></li><li>循环：<code>for { let i := 0 } lt(i, x) { i := add(i, 1) } { y := mul(2, y) }</code>。</li><li>If 语句：<code>if slt(x, 0) { x := sub(0, x) }</code>。</li><li>Switch 语句：<code>switch x case 0 { y := mul(x, 2) } default { y := 0 }</code>。</li><li>函数调用：<code>function f(x) -&gt; y { switch x case 0 { y := 1 } default { y := mul(x, f(sub(x, 1))) } }</code>。</li></ul><p>下面将详细介绍内联汇编。</p><p></p><div class="admonition warning"><p class="admonition-title">Warning</p><p>内联汇编是低级别操作以太坊虚拟机的一种方式。这抛弃了几个重要的安全特性。</p></div><div class="admonition note"><p class="admonition-title">Note</p><p>TODO:Write about how scoping rules of inline assembly are a bit different and the complications that arise when for example using internal functions of libraries. Furthermore, write about the symbols defined by the compiler.</p></div><p></p><h3 id="示例">示例</h3><p>以下示例提供了库代码来访问另一个合约代码并将其加载到一个字节变量中。这在“原生 Solidity” 中是完全无法做到的，思路是以汇编库代码来增强语言。</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">library</span> <span class="n">GetCode</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">at</span><span class="p">(</span><span class="kt">address</span> <span class="n">_addr</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes</span> <span class="n">o_code</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">assembly</span> <span class="p">{</span>
            <span class="c1">// 获取该地址合约代码大小 </span>
            <span class="ow">let</span> <span class="nv">size</span> <span class="o">:=</span> <span class="nf">extcodesize</span><span class="p">(</span><span class="n">_addr</span><span class="p">)</span>
            <span class="c1">// 分配字节数组，这也可使用 `o_code= new bytes(size)` 非汇编方式处理。 </span>
            <span class="n">o_code</span> <span class="o">:=</span> <span class="nf">mload</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
            <span class="c1">// 存储到包括填充的新“内存末端”</span>
            <span class="nf">mstore</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="n">o_code</span><span class="p">,</span> <span class="nf">and</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">),</span> <span class="mh">0x1f</span><span class="p">),</span> <span class="nf">not</span><span class="p">(</span><span class="mh">0x1f</span><span class="p">))))</span>
            <span class="c1">// 存储长度到内存</span>
            <span class="nf">mstore</span><span class="p">(</span><span class="n">o_code</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
            <span class="c1">// 需要用汇编才能获取代码</span>
            <span class="nf">extcodecopy</span><span class="p">(</span><span class="n">_addr</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="n">o_code</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在优化器无法无法生成高效代码时，用内联汇编是合适的。请注意，由于编译器不执行汇编检查，因此汇编更难编写，因此只有在确实知道所做时才用汇编处理复杂情况。</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">library</span> <span class="n">VectorSum</span> <span class="p">{</span>
    <span class="c1">// 此函数性能低效，因为目前编译器无法删除数组边界访问检查。</span>
    <span class="kd">function</span> <span class="n">sumSolidity</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="n">_data</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">o_sum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_data</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">o_sum</span> <span class="o">+=</span> <span class="n">_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// 应只能在边界内访问数组，可避免检查。</span>
    <span class="c1">// 因为数组第一个位置包含数组长度，因此需添加 0x20 到数组中。</span>
    <span class="kd">function</span> <span class="n">sumAsm</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="n">_data</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">o_sum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_data</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">assembly</span> <span class="p">{</span>
                <span class="n">o_sum</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">o_sum</span><span class="p">,</span> <span class="nf">mload</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">),</span> <span class="nf">mul</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">))))</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 同上，但完全使用汇编编写。</span>
    <span class="kd">function</span> <span class="n">sumPureAsm</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="n">_data</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">o_sum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">assembly</span> <span class="p">{</span>
           <span class="c1">// 从_data中加载前32个字节，并获得值，其值为数组长度。 </span>
           <span class="ow">let</span> <span class="nv">len</span> <span class="o">:=</span> <span class="nf">mload</span><span class="p">(</span><span class="n">_data</span><span class="p">)</span>

           <span class="c1">// 跳过长度字段。</span>
           <span class="c1">//</span>
           <span class="c1">// 用临时变量，用于递增。</span>
           <span class="c1">//</span>
           <span class="c1">// 注意： 递增 _data 后将使得原始 _data 变量不可用。</span>
           <span class="ow">let</span> <span class="nv">data</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>

           <span class="c1">// 迭代，直到超边界。</span>
           <span class="nf">for</span>
               <span class="p">{</span> <span class="ow">let</span> <span class="nv">end</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="p">}</span>
               <span class="nf">lt</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
               <span class="p">{</span> <span class="n">data</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span> <span class="p">}</span>
           <span class="p">{</span>
               <span class="n">o_sum</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">o_sum</span><span class="p">,</span> <span class="nf">mload</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
           <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="syntax">语法</h3><p>汇编同 Solidity 一样可解析注释、字面量和标识符，因此可用 <code>//</code>和<code>/**/</code>注释。内联汇编用<code>assembly { ...... }</code> 包住，内部可用如下：</p><ul><li>字面量，即 <code>0x123</code>、<code>42</code>或<code>&quot;abc&quot;</code>（字符串最多32个字符）。</li><li>字节操作码，如： <code>mload</code>、<code>sload</code>、<code>dup1</code>、<code>sstore</code>，具体见下列表。</li><li>函数指令，如：<code>add(1,mlod(0))</code>。</li><li>标签，如：<code>name:</code>。</li><li>定义变量，如：<code>let x := 7</code>、<code>let x:= add(y, 3)</code>或<code>let x</code>(初始化赋空值(0))。</li><li>标识符（标签或局部变量，以及作为内联汇编的外部变量），如：<code>jump(name)</code>、<code>3 x add</code>。</li><li>指令式赋值，如：<code>3 =: x</code>。</li><li>函数式赋值：如：<code>x := add(y, 3)</code>。</li><li>定义局部变量的作用域块，如：<code>{ let x := 3 { let y := add(x, 1) } }</code></li></ul><h3 id="操作码">操作码</h3><p>本节不对以太坊虚拟机完整描述，但可在汇编中参考以下操作码列表。</p><p>如果操作码需要参数（总是取自栈顶），用括号给出。注意，参数顺序可看做是非功能样式中的颠倒顺序（解释见下）。操作码列表中用<code>-</code>表示不会有操作计算结果推到栈中，用<code>*</code>表示特殊的，将推所有项到栈中。</p><p>如下，<code>mem[a...b]</code>表示将从位置<code>a</code>开始到位置<code>b</code>(不包含)的内存字节，<code>storeage[p]</code>表示存储位置<code>p</code>的内容。操作码<code>pushi</code>和<code>jumpdest</code>不能直接使用。在语法中，操作码被标为预定义的标识符。</p><table><thead><tr><th>字节码</th><th>特殊性</th><th>含义</th></tr></thead><tbody><tr><td>stop</td><td>-</td><td>停止执行，等同 <code>return(0,0)</code></td></tr><tr><td>add(x, y)</td><td></td><td>x + y</td></tr><tr><td>sub(x, y)</td><td></td><td>x - y</td></tr><tr><td>mul(x, y)</td><td></td><td>x * y</td></tr><tr><td>div(x, y)</td><td></td><td>x / y</td></tr><tr><td>sdiv(x, y)</td><td></td><td>x / y，针对二进制补码的有符号数</td></tr><tr><td>mod(x, y)</td><td></td><td>x % y</td></tr><tr><td>smod(x, y)</td><td></td><td>x % y，针对二进制补码的有符号数</td></tr><tr><td>exp(x, y)</td><td></td><td>x 的 y 次方</td></tr><tr><td>not(x)</td><td></td><td>~x, 对 x 的每一位取反</td></tr><tr><td>lt(x, y)</td><td></td><td>如果 x &lt; y 则为 1, 否则为 0</td></tr><tr><td>gt(x, y)</td><td></td><td>如果 x &gt; y 则为 1, 否则为 0</td></tr><tr><td>slt(x, y)</td><td></td><td>如果 x &lt; y 则为 1, 否则为 0，针对二进制补码的有符号数</td></tr><tr><td>sgt(x, y)</td><td></td><td>如果 x &gt; y 则为 1, 否则为 0，针对二进制补码的有符号数</td></tr><tr><td>eq(x, y)</td><td></td><td>如果 x == y 则为 1, 否则为 0</td></tr><tr><td>iszero(x)</td><td></td><td>如果 x == 0 则为 1, 否则为 0</td></tr><tr><td>and(x, y)</td><td></td><td>x &amp; y 位与</td></tr><tr><td>or(x, y)</td><td></td><td>x</td></tr><tr><td>xor(x, y)</td><td></td><td>x ^</td></tr><tr><td>byte(n, x)</td><td></td><td>x 的第 n 个字节，从 0 开始</td></tr><tr><td>addmod(x, y, m)</td><td></td><td>(x + y) % m 不丢失精确度</td></tr><tr><td>mulmod(x, y, m)</td><td></td><td>(x * y) % m 不丢失精确度</td></tr><tr><td>signextend(i, x)</td><td></td><td>符号从（i * 8 + 7）位计数从最低有效位延伸</td></tr><tr><td>keccak256(p, n)</td><td></td><td>keccak(mem[p&hellip;(p+n)))</td></tr><tr><td>sha3(p, n)</td><td></td><td>keccak(mem[p&hellip;(p+n)))</td></tr><tr><td>jump(label)</td><td><code>-</code></td><td>跳转到标签或代码位置</td></tr><tr><td>jumpi(label, cond)</td><td><code>-</code></td><td>如果条件为非0，则跳转至标签</td></tr><tr><td>pc</td><td></td><td>代码当前位置</td></tr><tr><td>pop(x)</td><td><code>-</code></td><td>移除由 x 推送的元素</td></tr><tr><td>dup1 &hellip; dup16</td><td></td><td>复制栈中第 i 个元素到栈顶（从栈顶计数）</td></tr><tr><td>swap1 &hellip; swap16</td><td><code>*</code></td><td>交换栈中第 i 个和栈顶元素</td></tr><tr><td>mload(p)</td><td></td><td>mem[p..(p+32))</td></tr><tr><td>mstore(p, v)</td><td><code>-</code></td><td>mem[p..(p+32)) := v</td></tr><tr><td>mstore8(p, v)</td><td><code>-</code></td><td>mem[p] := v &amp; 0xff - 只修改一个字节</td></tr><tr><td>sload(p)</td><td></td><td>storage[p]</td></tr><tr><td>sstore(p, v)</td><td><code>-</code></td><td>storage[p] := v</td></tr><tr><td>msize</td><td></td><td>内存大小，即可访问内存的最大索引</td></tr><tr><td>gas</td><td></td><td>当前可用 gas</td></tr><tr><td>address</td><td></td><td>当前合约或执行上下文的地址</td></tr><tr><td>balance(a)</td><td></td><td>地址 a 的余额，单位 wei</td></tr><tr><td>caller</td><td></td><td>调用者 (不包括委托调用)</td></tr><tr><td>callvalue</td><td></td><td>发送到当前调用的以太币，单位 wei</td></tr><tr><td>calldataload(p)</td><td></td><td>获取调用数据从位置 p 开始的 32 个字节数据</td></tr><tr><td>calldatasize</td><td></td><td>调用数据的大小，以字节表示</td></tr><tr><td>calldatacopy(t, f, s)</td><td><code>-</code></td><td>将调用数据 f 位置开始的 s 个字节复制到内存 t 位置</td></tr><tr><td>codesize</td><td></td><td>当前合约或执行上下文的代码长度</td></tr><tr><td>codecopy(t, f, s)</td><td><code>-</code></td><td>将代码 f 位置开始的 s 个字节复制到内存 t 位置</td></tr><tr><td>extcodesize(a)</td><td></td><td>地址 a 合约代码长度</td></tr><tr><td>extcodecopy(a, t, f, s)</td><td><code>-</code></td><td>类似 codecopy(t, f, s)，但取自地址 a 的合约代码</td></tr><tr><td>returndatasize</td><td></td><td>最后返回数据大小</td></tr><tr><td>returndatacopy(t, f, s)</td><td><code>-</code></td><td>将返回数据 f 位置开始的 s 个字节复制到内存 t 位置</td></tr><tr><td>create(v, p, s)</td><td></td><td>使用代码 <code>mem[p...(p+s)]</code>创建新合约且发送 v wei 资产，并返回合约代码</td></tr><tr><td>create2(v, n, p, s)</td><td></td><td>在指定地址<code>keccak256(&lt;address&gt; . n . keccak256(mem[p..(p+s)))</code><br>上使用代码<code>mem[p...(p+s)]</code>创建新合约且发送 v wei 资产，并返回合约代码</td></tr><tr><td>call(g, a, v, in,insize, out, outsize)</td><td></td><td>使用输入<code>mem[in..(in+insize))</code>调用合约 a，并指定 g 燃料量、v wei和 out 输出存放区域。调用成功时 mem[out..(out+outsize)) 为 1，否则为 0 （如 燃料耗尽）</td></tr><tr><td>callcode(g, a, v, in,insize, out, outsize)</td><td></td><td>同<code>call</code>，但只能使用 a 中的代码，否则将保留在当前合同的上下文中</td></tr><tr><td>delegatecall(g, a, in,insize, out, outsize)</td><td></td><td>同 <code>callcode</code> 但还保留 <code>caller</code>和 <code>callvalue</code></td></tr><tr><td>staticcall(g, a, in,insize, out, outsize)</td><td></td><td>形同 <code>call(g, a, 0, in, insize, out, outsize)</code> 但不允许修改状态</td></tr><tr><td>return(p, s)</td><td><code>-</code></td><td>结束执行，返回数据 <code>mem[p..(p+s))</code></td></tr><tr><td>revert(p, s)</td><td><code>-</code></td><td>结束执行并恢复状态修改，返回数据<code>mem[p..(p+s))</code></td></tr><tr><td>selfdestruct(a)</td><td><code>-</code></td><td>结束执行并销毁当前合约，将合约资产转移给 a</td></tr><tr><td>invalid</td><td><code>-</code></td><td>结束执行并反馈为无效指令</td></tr><tr><td>log0(p, s)</td><td><code>-</code></td><td>记录无主题日志 <code>mem[p..(p+s))</code></td></tr><tr><td>log1(p, s, t1)</td><td><code>-</code></td><td>在主题 t1 下记录日志 <code>mem[p..(p+s))</code></td></tr><tr><td>log2(p, s, t1, t2)</td><td><code>-</code></td><td>在主题 t1、t2 下记录日志 <code>mem[p..(p+s))</code></td></tr><tr><td>log3(p, s, t1, t2, t3)</td><td><code>-</code></td><td>在主题 t1、t2、t3 下记录日志 <code>mem[p..(p+s))</code></td></tr><tr><td>log4(p, s, t1, t2, t3,t4)</td><td><code>-</code></td><td>在主题 t1、t2、t3、t4 下记录日志 <code>mem[p..(p+s))</code></td></tr><tr><td>origin</td><td></td><td>获取交易发送者</td></tr><tr><td>gasprice</td><td></td><td>获取交易中所设置的燃油单价</td></tr><tr><td>blockhash(b)</td><td></td><td>指定区块 b 的哈希值 - 只能处理除当前区块外的最后 256 个区块</td></tr><tr><td>coinbase</td><td></td><td>当前挖矿受益人</td></tr><tr><td>timestamp</td><td></td><td>当前区块的秒级时间戳</td></tr><tr><td>number</td><td></td><td>当前区块高度</td></tr><tr><td>difficulty</td><td></td><td>当前区块难度值</td></tr><tr><td>gaslimit</td><td></td><td>当前区块燃料限制</td></tr></tbody></table><h3 id="Literals">字面量</h3><p>可使用十进制或十六进制符号写入整型常量，并自动生成相应的<code>PUSHI</code>指令。下面示例中将 2 和 3 加起来得到 5，然后与字符串“abc” 进行位与计算。字符串存储为左对齐，不能超过32个字节。</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="k">assembly</span> <span class="p">{</span> <span class="mi">2</span> <span class="mi">3</span> <span class="nf">add</span> <span class="s">&quot;abc&quot;</span> <span class="nf">and</span> <span class="p">}</span>
</code></pre></div><h3 id="Functional-Style">函数式</h3><p>可在操作码后面接着输入操作码，同样地也会生成字节码。比如：添加内容<code>3</code>到内存<code>0x80</code>位置：</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="mi">3</span> <span class="mh">0x80</span> <span class="n">mload</span> <span class="n">add</span> <span class="mh">0x80</span> <span class="n">mstore</span>
</code></pre></div><p>可通常很难看清某些操作码的实际参数是什么，Solidity 内联汇编中提供了&rdquo;函数式&rdquo;表示法，上面指令式代码可写成：</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="n">mstore</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">mload</span><span class="p">(</span><span class="mh">0x80</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
</code></pre></div><p>函数式表达式不能用于指令式中，即：<code>1 2 mstore(0x80, add)</code> 非法，必须写成 <code>mstore(0x80, add(2, 1))</code>。 对于无参操作码，括号可以省略。</p><p>注意，参数的顺序在函数式上与指令式方式相反。如果使用函数式，第一个参数将会在栈顶。</p><h3 id="access-to-external-variables-and-functions">Access to External Variables and Functions</h3><p>Solidity variables and other identifiers can be accessed by simply using their name. For memory variables, this will push the address and not the value onto the stack. Storage variables are different: Values in storage might not occupy a full storage slot, so their &ldquo;address&rdquo; is composed of a slot and a byte-offset inside that slot. To retrieve the slot pointed to by the variable <code>x</code>, you used <code>x_slot</code> and to retrieve the byte-offset you used <code>x_offset</code>.</p><p>In assignments (see below), we can even use local Solidity variables to assign to.</p><p>Functions external to inline assembly can also be accessed: The assembly will push their entry label (with virtual function resolution applied). The calling semantics in solidity are:</p><ul><li>the caller pushes <code>return label</code>, <code>arg1</code>, <code>arg2</code>, &hellip;, <code>argn</code></li><li>the call returns with <code>ret1</code>, <code>ret2</code>, &hellip;, <code>retm</code></li></ul><p>This feature is still a bit cumbersome to use, because the stack offset essentially changes during the call, and thus references to local variables will be wrong.</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>
<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="n">b</span><span class="p">;</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">)</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">assembly</span> <span class="p">{</span>
            <span class="n">r</span> <span class="o">:=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nf">sload</span><span class="p">(</span><span class="n">b_slot</span><span class="p">))</span> <span class="c1">// ignore the offset, we know it is zero</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="labels">Labels</h3><p>Another problem in EVM assembly is that <code>jump</code> and <code>jumpi</code> use absolute addresses which can change easily. Solidity inline assembly provides labels to make the use of jumps easier. Note that labels are a low-level feature and it is possible to write efficient assembly without labels, just using assembly functions, loops, if and switch instructions (see below). The following code computes an element in the Fibonacci series.</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="p">{</span>
    <span class="n">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">calldataload</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">let</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="n">let</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">a</span>
<span class="n">loop</span><span class="o">:</span>
    <span class="n">jumpi</span><span class="p">(</span><span class="n">loopend</span><span class="p">,</span> <span class="n">eq</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">a</span> <span class="n">add</span> <span class="n">swap1</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="n">sub</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">jump</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
<span class="n">loopend</span><span class="o">:</span>
    <span class="n">mstore</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>Please note that automatically accessing stack variables can only work if the assembler knows the current stack height. This fails to work if the jump source and target have different stack heights. It is still fine to use such jumps, but you should just not access any stack variables (even assembly variables) in that case.</p><p>Furthermore, the stack height analyser goes through the code opcode by opcode (and not according to control flow), so in the following case, the assembler will have a wrong impression about the stack height at label <code>two</code>:</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="p">{</span>
    <span class="n">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">8</span>
    <span class="n">jump</span><span class="p">(</span><span class="n">two</span><span class="p">)</span>
    <span class="n">one</span><span class="o">:</span>
        <span class="c1">// Here the stack height is 2 (because we pushed x and 7),</span>
        <span class="c1">// but the assembler thinks it is 1 because it reads</span>
        <span class="c1">// from top to bottom.</span>
        <span class="c1">// Accessing the stack variable x here will lead to errors.</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="mi">9</span>
        <span class="n">jump</span><span class="p">(</span><span class="n">three</span><span class="p">)</span>
    <span class="n">two</span><span class="o">:</span>
        <span class="mi">7</span> <span class="c1">// push something onto the stack</span>
        <span class="n">jump</span><span class="p">(</span><span class="n">one</span><span class="p">)</span>
    <span class="n">three</span><span class="o">:</span>
<span class="p">}</span>
</code></pre></div><h3 id="declaring-assembly-local-variables">Declaring Assembly-Local Variables</h3><p>You can use the <code>let</code> keyword to declare variables that are only visible in inline assembly and actually only in the current <code>{...}</code>-block. What happens is that the <code>let</code> instruction will create a new stack slot that is reserved for the variable and automatically removed again when the end of the block is reached. You need to provide an initial value for the variable which can be just <code>0</code>, but it can also be a complex functional-style expression.</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>
<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">assembly</span> <span class="p">{</span>
            <span class="ow">let</span> <span class="nv">v</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="nf">mstore</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="ow">let</span> <span class="nv">y</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nf">sload</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">b</span> <span class="o">:=</span> <span class="n">y</span>
            <span class="p">}</span> <span class="c1">// y is &quot;deallocated&quot; here</span>
            <span class="n">b</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="p">}</span> <span class="c1">// v is &quot;deallocated&quot; here</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="assignments">Assignments</h3><p>Assignments are possible to assembly-local variables and to function-local variables. Take care that when you assign to variables that point to memory or storage, you will only change the pointer and not the data.</p><p>There are two kinds of assignments: functional-style and instruction-style. For functional-style assignments (<code>variable := value</code>), you need to provide a value in a functional-style expression that results in exactly one stack value and for instruction-style (<code>=: variable</code>), the value is just taken from the stack top. For both ways, the colon points to the name of the variable. The assignment is performed by replacing the variable&rsquo;s value on the stack by the new value.</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="p">{</span>
    <span class="n">let</span> <span class="n">v</span> <span class="o">:=</span> <span class="mi">0</span> <span class="c1">// functional-style assignment as part of variable declaration</span>
    <span class="n">let</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">sload</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="o">=:</span> <span class="n">v</span> <span class="c1">// instruction style assignment, puts the result of sload(10) into v</span>
<span class="p">}</span>
</code></pre></div><h3 id="if">If</h3><p>The if statement can be used for conditionally executing code. There is no &ldquo;else&rdquo; part, consider using &ldquo;switch&rdquo; (see below) if you need multiple alternatives.</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="p">{</span>
    <span class="k">if</span> <span class="n">eq</span><span class="p">(</span><span class="nb">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nb">revert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>The curly braces for the body are required.</p><h3 id="switch">Switch</h3><p>You can use a switch statement as a very basic version of &ldquo;if/else&rdquo;. It takes the value of an expression and compares it to several constants. The branch corresponding to the matching constant is taken. Contrary to the error-prone behaviour of some programming languages, control flow does not continue from one case to the next. There can be a fallback or default case called <code>default</code>.</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="p">{</span>
    <span class="n">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="n">switch</span> <span class="n">calldataload</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">case</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="n">calldataload</span><span class="p">(</span><span class="mh">0x24</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kr">default</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="n">calldataload</span><span class="p">(</span><span class="mh">0x44</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">sstore</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>The list of cases does not require curly braces, but the body of a case does require them.</p><h3 id="loops">Loops</h3><p>Assembly supports a simple for-style loop. For-style loops have a header containing an initializing part, a condition and a post-iteration part. The condition has to be a functional-style expression, while the other two are blocks. If the initializing part declares any variables, the scope of these variables is extended into the body (including the condition and the post-iteration part).</p><p>The following example computes the sum of an area in memory.</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="p">{</span>
    <span class="n">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">{</span> <span class="n">let</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">}</span> <span class="n">lt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span> <span class="p">}</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mload</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>For loops can also be written so that they behave like while loops: Simply leave the initialization and post-iteration parts empty.</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="p">{</span>
    <span class="n">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="n">let</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">{</span> <span class="p">}</span> <span class="n">lt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="p">{</span>     <span class="c1">// while(i &lt; 0x100)</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mload</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">i</span> <span class="o">:=</span> <span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="functions">Functions</h3><p>Assembly allows the definition of low-level functions. These take their arguments (and a return PC) from the stack and also put the results onto the stack. Calling a function looks the same way as executing a functional-style opcode.</p><p>Functions can be defined anywhere and are visible in the block they are declared in. Inside a function, you cannot access local variables defined outside of that function. There is no explicit <code>return</code> statement.</p><p>If you call a function that returns multiple values, you have to assign them to a tuple using <code>a, b := f(x)</code> or <code>let a, b := f(x)</code>.</p><p>The following example implements the power function by square-and-multiply.</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="p">{</span>
    <span class="kd">function</span> <span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">result</span> <span class="p">{</span>
        <span class="n">switch</span> <span class="n">exponent</span>
        <span class="n">case</span> <span class="mi">0</span> <span class="p">{</span> <span class="n">result</span> <span class="o">:=</span> <span class="mi">1</span> <span class="p">}</span>
        <span class="n">case</span> <span class="mi">1</span> <span class="p">{</span> <span class="n">result</span> <span class="o">:=</span> <span class="n">base</span> <span class="p">}</span>
        <span class="kr">default</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">:=</span> <span class="n">power</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">base</span><span class="p">),</span> <span class="n">div</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">switch</span> <span class="n">mod</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">case</span> <span class="mi">1</span> <span class="p">{</span> <span class="n">result</span> <span class="o">:=</span> <span class="n">mul</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="things-to-avoid">Things to Avoid</h3><p>Inline assembly might have a quite high-level look, but it actually is extremely low-level. Function calls, loops, ifs and switches are converted by simple rewriting rules and after that, the only thing the assembler does for you is re-arranging functional-style opcodes, managing jump labels, counting stack height for variable access and removing stack slots for assembly-local variables when the end of their block is reached. Especially for those two last cases, it is important to know that the assembler only counts stack height from top to bottom, not necessarily following control flow. Furthermore, operations like swap will only swap the contents of the stack but not the location of variables.</p><h3 id="conventions-in-solidity">Conventions in Solidity</h3><p>In contrast to EVM assembly, Solidity knows types which are narrower than 256 bits, e.g. <code>uint24</code>. In order to make them more efficient, most arithmetic operations just treat them as 256-bit numbers and the higher-order bits are only cleaned at the point where it is necessary, i.e. just shortly before they are written to memory or before comparisons are performed. This means that if you access such a variable from within inline assembly, you might have to manually clean the higher order bits first.</p><p>Solidity manages memory in a very simple way: There is a &ldquo;free memory pointer&rdquo; at position <code>0x40</code> in memory. If you want to allocate memory, just use the memory from that point on and update the pointer accordingly.</p><p>Elements in memory arrays in Solidity always occupy multiples of 32 bytes (yes, this is even true for <code>byte[]</code>, but not for <code>bytes</code> and <code>string</code>). Multi-dimensional memory arrays are pointers to memory arrays. The length of a dynamic array is stored at the first slot of the array and then only the array elements follow.</p><div class="admonition waring"><p class="admonition-title">Waring</p><p><pre><code>Statically-sized memory arrays do not have a length field, but it will be added soon
to allow better convertibility between statically- and dynamically-sized arrays, so
please do not rely on that.
</code></pre></p></div><h2 id="standalone-assembly">Standalone Assembly</h2><p>The assembly language described as inline assembly above can also be used standalone and in fact, the plan is to use it as an intermediate language for the Solidity compiler. In this form, it tries to achieve several goals:</p><ol><li>Programs written in it should be readable, even if the code is generated by a compiler from Solidity.</li><li>The translation from assembly to bytecode should contain as few &ldquo;surprises&rdquo; as possible.</li><li>Control flow should be easy to detect to help in formal verification and optimization.</li></ol><p>In order to achieve the first and last goal, assembly provides high-level constructs like <code>for</code> loops, <code>if</code> and <code>switch</code> statements and function calls. It should be possible to write assembly programs that do not make use of explicit <code>SWAP</code>, <code>DUP</code>, <code>JUMP</code> and <code>JUMPI</code> statements, because the first two obfuscate the data flow and the last two obfuscate control flow. Furthermore, functional statements of the form <code>mul(add(x, y), 7)</code> are preferred over pure opcode statements like <code>7 y x add mul</code> because in the first form, it is much easier to see which operand is used for which opcode.</p><p>The second goal is achieved by introducing a desugaring phase that only removes the higher level constructs in a very regular way and still allows inspecting the generated low-level assembly code. The only non-local operation performed by the assembler is name lookup of user-defined identifiers (functions, variables, &hellip;), which follow very simple and regular scoping rules and cleanup of local variables from the stack.</p><p>Scoping: An identifier that is declared (label, variable, function, assembly) is only visible in the block where it was declared (including nested blocks inside the current block). It is not legal to access local variables across function borders, even if they would be in scope. Shadowing is not allowed. Local variables cannot be accessed before they were declared, but labels, functions and assemblies can. Assemblies are special blocks that are used for e.g. returning runtime code or creating contracts. No identifier from an outer assembly is visible in a sub-assembly.</p><p>If control flow passes over the end of a block, pop instructions are inserted that match the number of local variables declared in that block. Whenever a local variable is referenced, the code generator needs to know its current relative position in the stack and thus it needs to keep track of the current so-called stack height. Since all local variables are removed at the end of a block, the stack height before and after the block should be the same. If this is not the case, a warning is issued.</p><p>Why do we use higher-level constructs like <code>switch</code>, <code>for</code> and functions:</p><p>Using <code>switch</code>, <code>for</code> and functions, it should be possible to write complex code without using <code>jump</code> or <code>jumpi</code> manually. This makes it much easier to analyze the control flow, which allows for improved formal verification and optimization.</p><p>Furthermore, if manual jumps are allowed, computing the stack height is rather complicated. The position of all local variables on the stack needs to be known, otherwise neither references to local variables nor removing local variables automatically from the stack at the end of a block will work properly. The desugaring mechanism correctly inserts operations at unreachable blocks that adjust the stack height properly in case of jumps that do not have a continuing control flow.</p><p>Example:</p><p>We will follow an example compilation from Solidity to desugared assembly. We consider the runtime bytecode of the following Solidity program::</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>
<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>The following assembly will be generated::</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="p">{</span>
  <span class="n">mstore</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">)</span> <span class="c1">// store the &quot;free memory pointer&quot;</span>
  <span class="c1">// function dispatcher</span>
  <span class="n">switch</span> <span class="n">div</span><span class="p">(</span><span class="n">calldataload</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">226</span><span class="p">))</span>
  <span class="n">case</span> <span class="mh">0xb3de648b</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">f</span><span class="p">(</span><span class="n">calldataload</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">let</span> <span class="n">ret</span> <span class="o">:=</span> <span class="err">$</span><span class="n">allocate</span><span class="p">(</span><span class="mh">0x20</span><span class="p">)</span>
    <span class="n">mstore</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kr">default</span> <span class="p">{</span> <span class="nb">revert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
  <span class="c1">// memory allocator</span>
  <span class="kd">function</span> <span class="err">$</span><span class="n">allocate</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pos</span> <span class="p">{</span>
    <span class="n">pos</span> <span class="o">:=</span> <span class="n">mload</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
    <span class="n">mstore</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="c1">// the contract function</span>
  <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">y</span> <span class="p">{</span>
    <span class="n">y</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="p">{</span> <span class="n">let</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">}</span> <span class="n">lt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="p">{</span>
      <span class="n">y</span> <span class="o">:=</span> <span class="n">mul</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>After the desugaring phase it looks as follows::</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span><span class="p">{</span>
  <span class="n">mstore</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">let</span> <span class="err">$</span><span class="mi">0</span> <span class="o">:=</span> <span class="n">div</span><span class="p">(</span><span class="n">calldataload</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">226</span><span class="p">))</span>
    <span class="n">jumpi</span><span class="p">(</span><span class="err">$</span><span class="n">case1</span><span class="p">,</span> <span class="n">eq</span><span class="p">(</span><span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0xb3de648b</span><span class="p">))</span>
    <span class="n">jump</span><span class="p">(</span><span class="err">$</span><span class="n">caseDefault</span><span class="p">)</span>
    <span class="err">$</span><span class="n">case1</span><span class="o">:</span>
    <span class="p">{</span>
      <span class="c1">// the function call - we put return label and arguments on the stack</span>
      <span class="err">$</span><span class="n">ret1</span> <span class="n">calldataload</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">jump</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
      <span class="c1">// This is unreachable code. Opcodes are added that mirror the</span>
      <span class="c1">// effect of the function on the stack height: Arguments are</span>
      <span class="c1">// removed and return values are introduced.</span>
      <span class="n">pop</span> <span class="n">pop</span>
      <span class="n">let</span> <span class="n">r</span> <span class="o">:=</span> <span class="mi">0</span>
      <span class="err">$</span><span class="n">ret1</span><span class="o">:</span> <span class="c1">// the actual return point</span>
      <span class="err">$</span><span class="n">ret2</span> <span class="mh">0x20</span> <span class="n">jump</span><span class="p">(</span><span class="err">$</span><span class="n">allocate</span><span class="p">)</span>
      <span class="n">pop</span> <span class="n">pop</span> <span class="n">let</span> <span class="n">ret</span> <span class="o">:=</span> <span class="mi">0</span>
      <span class="err">$</span><span class="n">ret2</span><span class="o">:</span>
      <span class="n">mstore</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
      <span class="k">return</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>
      <span class="c1">// although it is useless, the jump is automatically inserted,</span>
      <span class="c1">// since the desugaring process is a purely syntactic operation that</span>
      <span class="c1">// does not analyze control-flow</span>
      <span class="n">jump</span><span class="p">(</span><span class="err">$</span><span class="n">endswitch</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="err">$</span><span class="n">caseDefault</span><span class="o">:</span>
    <span class="p">{</span>
      <span class="nb">revert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">jump</span><span class="p">(</span><span class="err">$</span><span class="n">endswitch</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="err">$</span><span class="n">endswitch</span><span class="o">:</span>
  <span class="p">}</span>
  <span class="n">jump</span><span class="p">(</span><span class="err">$</span><span class="n">afterFunction</span><span class="p">)</span>
  <span class="n">allocate</span><span class="o">:</span>
  <span class="p">{</span>
    <span class="c1">// we jump over the unreachable code that introduces the function arguments</span>
    <span class="n">jump</span><span class="p">(</span><span class="err">$</span><span class="n">start</span><span class="p">)</span>
    <span class="n">let</span> <span class="err">$</span><span class="n">retpos</span> <span class="o">:=</span> <span class="mi">0</span> <span class="n">let</span> <span class="n">size</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="err">$</span><span class="n">start</span><span class="o">:</span>
    <span class="c1">// output variables live in the same scope as the arguments and is</span>
    <span class="c1">// actually allocated.</span>
    <span class="n">let</span> <span class="n">pos</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="p">{</span>
      <span class="n">pos</span> <span class="o">:=</span> <span class="n">mload</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
      <span class="n">mstore</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="c1">// This code replaces the arguments by the return values and jumps back.</span>
    <span class="n">swap1</span> <span class="n">pop</span> <span class="n">swap1</span> <span class="n">jump</span>
    <span class="c1">// Again unreachable code that corrects stack height.</span>
    <span class="mi">0</span> <span class="mi">0</span>
  <span class="p">}</span>
  <span class="n">f</span><span class="o">:</span>
  <span class="p">{</span>
    <span class="n">jump</span><span class="p">(</span><span class="err">$</span><span class="n">start</span><span class="p">)</span>
    <span class="n">let</span> <span class="err">$</span><span class="n">retpos</span> <span class="o">:=</span> <span class="mi">0</span> <span class="n">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="err">$</span><span class="n">start</span><span class="o">:</span>
    <span class="n">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="p">{</span>
      <span class="n">let</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span>
      <span class="err">$</span><span class="n">for_begin</span><span class="o">:</span>
      <span class="n">jumpi</span><span class="p">(</span><span class="err">$</span><span class="n">for_end</span><span class="p">,</span> <span class="n">iszero</span><span class="p">(</span><span class="n">lt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)))</span>
      <span class="p">{</span>
        <span class="n">y</span> <span class="o">:=</span> <span class="n">mul</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="err">$</span><span class="n">for_continue</span><span class="o">:</span>
      <span class="p">{</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">jump</span><span class="p">(</span><span class="err">$</span><span class="n">for_begin</span><span class="p">)</span>
      <span class="err">$</span><span class="n">for_end</span><span class="o">:</span>
    <span class="p">}</span> <span class="c1">// Here, a pop instruction will be inserted for i</span>
    <span class="n">swap1</span> <span class="n">pop</span> <span class="n">swap1</span> <span class="n">jump</span>
    <span class="mi">0</span> <span class="mi">0</span>
  <span class="p">}</span>
  <span class="err">$</span><span class="n">afterFunction</span><span class="o">:</span>
  <span class="n">stop</span>
<span class="p">}</span>
</code></pre></div><p>Assembly happens in four stages:</p><ol><li>Parsing</li><li>Desugaring (removes switch, for and functions)</li><li>Opcode stream generation</li><li>Bytecode generation</li></ol><p>We will specify steps one to three in a pseudo-formal way. More formal specifications will follow.</p><h3 id="parsing-grammar">Parsing / Grammar</h3><p>The tasks of the parser are the following:</p><ul><li>Turn the byte stream into a token stream, discarding C++-style comments (a special comment exists for source references, but we will not explain it here).</li><li>Turn the token stream into an AST according to the grammar below</li><li>Register identifiers with the block they are defined in (annotation to the AST node) and note from which point on, variables can be accessed.</li></ul><p>The assembly lexer follows the one defined by Solidity itself.</p><p>Whitespace is used to delimit tokens and it consists of the characters Space, Tab and Linefeed. Comments are regular JavaScript/C++ comments and are interpreted in the same way as Whitespace.</p><p>Grammar::</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span>    <span class="n">AssemblyBlock</span> <span class="o">=</span> <span class="s">&#39;{&#39;</span> <span class="n">AssemblyItem</span><span class="o">*</span> <span class="s">&#39;}&#39;</span>
    <span class="n">AssemblyItem</span> <span class="o">=</span>
        <span class="n">Identifier</span> <span class="o">|</span>
        <span class="n">AssemblyBlock</span> <span class="o">|</span>
        <span class="n">AssemblyExpression</span> <span class="o">|</span>
        <span class="n">AssemblyLocalDefinition</span> <span class="o">|</span>
        <span class="n">AssemblyAssignment</span> <span class="o">|</span>
        <span class="n">AssemblyStackAssignment</span> <span class="o">|</span>
        <span class="n">LabelDefinition</span> <span class="o">|</span>
        <span class="n">AssemblyIf</span> <span class="o">|</span>
        <span class="n">AssemblySwitch</span> <span class="o">|</span>
        <span class="n">AssemblyFunctionDefinition</span> <span class="o">|</span>
        <span class="n">AssemblyFor</span> <span class="o">|</span>
        <span class="s">&#39;break&#39;</span> <span class="o">|</span>
        <span class="s">&#39;continue&#39;</span> <span class="o">|</span>
        <span class="n">SubAssembly</span>
    <span class="n">AssemblyExpression</span> <span class="o">=</span> <span class="n">AssemblyCall</span> <span class="o">|</span> <span class="n">Identifier</span> <span class="o">|</span> <span class="n">AssemblyLiteral</span>
    <span class="n">AssemblyLiteral</span> <span class="o">=</span> <span class="n">NumberLiteral</span> <span class="o">|</span> <span class="n">StringLiteral</span> <span class="o">|</span> <span class="n">HexLiteral</span>
    <span class="n">Identifier</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="n">zA</span><span class="o">-</span><span class="n">Z_</span><span class="err">$</span><span class="p">]</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="n">zA</span><span class="o">-</span><span class="n">Z_0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">*</span>
    <span class="n">AssemblyCall</span> <span class="o">=</span> <span class="n">Identifier</span> <span class="s">&#39;(&#39;</span> <span class="p">(</span> <span class="n">AssemblyExpression</span> <span class="p">(</span> <span class="s">&#39;,&#39;</span> <span class="n">AssemblyExpression</span> <span class="p">)</span><span class="o">*</span> <span class="p">)</span><span class="o">?</span> <span class="s">&#39;)&#39;</span>
    <span class="n">AssemblyLocalDefinition</span> <span class="o">=</span> <span class="s">&#39;let&#39;</span> <span class="n">IdentifierOrList</span> <span class="p">(</span> <span class="s">&#39;:=&#39;</span> <span class="n">AssemblyExpression</span> <span class="p">)</span><span class="o">?</span>
    <span class="n">AssemblyAssignment</span> <span class="o">=</span> <span class="n">IdentifierOrList</span> <span class="s">&#39;:=&#39;</span> <span class="n">AssemblyExpression</span>
    <span class="n">IdentifierOrList</span> <span class="o">=</span> <span class="n">Identifier</span> <span class="o">|</span> <span class="s">&#39;(&#39;</span> <span class="n">IdentifierList</span> <span class="s">&#39;)&#39;</span>
    <span class="n">IdentifierList</span> <span class="o">=</span> <span class="n">Identifier</span> <span class="p">(</span> <span class="s">&#39;,&#39;</span> <span class="n">Identifier</span><span class="p">)</span><span class="o">*</span>
    <span class="n">AssemblyStackAssignment</span> <span class="o">=</span> <span class="s">&#39;=:&#39;</span> <span class="n">Identifier</span>
    <span class="n">LabelDefinition</span> <span class="o">=</span> <span class="n">Identifier</span> <span class="s">&#39;:&#39;</span>
    <span class="n">AssemblyIf</span> <span class="o">=</span> <span class="s">&#39;if&#39;</span> <span class="n">AssemblyExpression</span> <span class="n">AssemblyBlock</span>
    <span class="n">AssemblySwitch</span> <span class="o">=</span> <span class="s">&#39;switch&#39;</span> <span class="n">AssemblyExpression</span> <span class="n">AssemblyCase</span><span class="o">*</span>
        <span class="p">(</span> <span class="s">&#39;default&#39;</span> <span class="n">AssemblyBlock</span> <span class="p">)</span><span class="o">?</span>
    <span class="n">AssemblyCase</span> <span class="o">=</span> <span class="s">&#39;case&#39;</span> <span class="n">AssemblyExpression</span> <span class="n">AssemblyBlock</span>
    <span class="n">AssemblyFunctionDefinition</span> <span class="o">=</span> <span class="s">&#39;function&#39;</span> <span class="n">Identifier</span> <span class="s">&#39;(&#39;</span> <span class="n">IdentifierList</span><span class="o">?</span> <span class="s">&#39;)&#39;</span>
        <span class="p">(</span> <span class="s">&#39;-&gt;&#39;</span> <span class="s">&#39;(&#39;</span> <span class="n">IdentifierList</span> <span class="s">&#39;)&#39;</span> <span class="p">)</span><span class="o">?</span> <span class="n">AssemblyBlock</span>
    <span class="n">AssemblyFor</span> <span class="o">=</span> <span class="s">&#39;for&#39;</span> <span class="p">(</span> <span class="n">AssemblyBlock</span> <span class="o">|</span> <span class="n">AssemblyExpression</span> <span class="p">)</span>
        <span class="n">AssemblyExpression</span> <span class="p">(</span> <span class="n">AssemblyBlock</span> <span class="o">|</span> <span class="n">AssemblyExpression</span> <span class="p">)</span> <span class="n">AssemblyBlock</span>
    <span class="n">SubAssembly</span> <span class="o">=</span> <span class="s">&#39;assembly&#39;</span> <span class="n">Identifier</span> <span class="n">AssemblyBlock</span>
    <span class="n">NumberLiteral</span> <span class="o">=</span> <span class="n">HexNumber</span> <span class="o">|</span> <span class="n">DecimalNumber</span>
    <span class="n">HexLiteral</span> <span class="o">=</span> <span class="s">&#39;hex&#39;</span> <span class="p">(</span><span class="s">&#39;&quot;&#39;</span> <span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="n">a</span><span class="o">-</span><span class="n">fA</span><span class="o">-</span><span class="n">F</span><span class="p">]{</span><span class="mi">2</span><span class="p">})</span><span class="o">*</span> <span class="s">&#39;&quot;&#39;</span> <span class="o">|</span> <span class="s">&#39;</span><span class="se">\&#39;</span><span class="s">&#39;</span> <span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="n">a</span><span class="o">-</span><span class="n">fA</span><span class="o">-</span><span class="n">F</span><span class="p">]{</span><span class="mi">2</span><span class="p">})</span><span class="o">*</span> <span class="s">&#39;</span><span class="se">\&#39;</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="n">StringLiteral</span> <span class="o">=</span> <span class="s">&#39;&quot;&#39;</span> <span class="p">([</span><span class="o">^</span><span class="s">&quot;</span><span class="se">\r\n\\</span><span class="s">] | &#39;</span><span class="se">\\</span><span class="s">&#39; .)* &#39;&quot;&#39;</span>
    <span class="n">HexNumber</span> <span class="o">=</span> <span class="s">&#39;0x&#39;</span> <span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="n">a</span><span class="o">-</span><span class="n">fA</span><span class="o">-</span><span class="n">F</span><span class="p">]</span><span class="o">+</span>
    <span class="n">DecimalNumber</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span>
</code></pre></div><h3 id="desugaring">Desugaring</h3><p>An AST transformation removes for, switch and function constructs. The result is still parseable by the same parser, but it will not use certain constructs. If jumpdests are added that are only jumped to and not continued at, information about the stack content is added, unless no local variables of outer scopes are accessed or the stack height is the same as for the previous instruction.</p><p>Pseudocode::</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span>    <span class="n">desugar</span> <span class="n">item</span><span class="o">:</span> <span class="n">AST</span> <span class="o">-&gt;</span> <span class="n">AST</span> <span class="o">=</span>
    <span class="n">match</span> <span class="n">item</span> <span class="p">{</span>
    <span class="n">AssemblyFunctionDefinition</span><span class="p">(</span><span class="s">&#39;function&#39;</span> <span class="n">name</span> <span class="s">&#39;(&#39;</span> <span class="n">arg1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">argn</span> <span class="s">&#39;)&#39;</span> <span class="s">&#39;-&gt;&#39;</span> <span class="p">(</span> <span class="s">&#39;(&#39;</span> <span class="n">ret1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">retm</span> <span class="s">&#39;)&#39;</span> <span class="n">body</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;:</span>
      <span class="p">{</span>
        <span class="n">jump</span><span class="p">(</span><span class="err">$</span><span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="n">_start</span><span class="p">)</span>
        <span class="n">let</span> <span class="err">$</span><span class="n">retPC</span> <span class="o">:=</span> <span class="mi">0</span> <span class="n">let</span> <span class="n">argn</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">...</span> <span class="n">let</span> <span class="n">arg1</span> <span class="o">:=</span> <span class="mi">0</span>
        <span class="err">$</span><span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="n">_start</span><span class="o">:</span>
        <span class="n">let</span> <span class="n">ret1</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">...</span> <span class="n">let</span> <span class="n">retm</span> <span class="o">:=</span> <span class="mi">0</span>
        <span class="p">{</span> <span class="n">desugar</span><span class="p">(</span><span class="n">body</span><span class="p">)</span> <span class="p">}</span>
        <span class="n">swap</span> <span class="n">and</span> <span class="n">pop</span> <span class="n">items</span> <span class="n">so</span> <span class="n">that</span> <span class="n">only</span> <span class="n">ret1</span><span class="p">,</span> <span class="p">...</span> <span class="n">retm</span><span class="p">,</span> <span class="err">$</span><span class="n">retPC</span> <span class="n">are</span> <span class="n">left</span> <span class="n">on</span> <span class="n">the</span> <span class="n">stack</span>
        <span class="n">jump</span>
        <span class="mi">0</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n</span> <span class="n">times</span><span class="p">)</span> <span class="n">to</span> <span class="n">compensate</span> <span class="n">removal</span> <span class="n">of</span> <span class="n">arg1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">argn</span> <span class="n">and</span> <span class="err">$</span><span class="n">retPC</span>
      <span class="p">}</span>
    <span class="n">AssemblyFor</span><span class="p">(</span><span class="s">&#39;for&#39;</span> <span class="p">{</span> <span class="n">init</span> <span class="p">}</span> <span class="n">condition</span> <span class="n">post</span> <span class="n">body</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="p">{</span>
        <span class="n">init</span> <span class="c1">// cannot be its own block because we want variable scope to extend into the body</span>
        <span class="c1">// find I such that there are no labels $forI_*</span>
        <span class="err">$</span><span class="n">forI_begin</span><span class="o">:</span>
        <span class="n">jumpi</span><span class="p">(</span><span class="err">$</span><span class="n">forI_end</span><span class="p">,</span> <span class="n">iszero</span><span class="p">(</span><span class="n">condition</span><span class="p">))</span>
        <span class="p">{</span> <span class="n">body</span> <span class="p">}</span>
        <span class="err">$</span><span class="n">forI_continue</span><span class="o">:</span>
        <span class="p">{</span> <span class="n">post</span> <span class="p">}</span>
        <span class="n">jump</span><span class="p">(</span><span class="err">$</span><span class="n">forI_begin</span><span class="p">)</span>
        <span class="err">$</span><span class="n">forI_end</span><span class="o">:</span>
      <span class="p">}</span>
    <span class="s">&#39;break&#39;</span> <span class="o">-&gt;</span>
      <span class="p">{</span>
        <span class="c1">// find nearest enclosing scope with label $forI_end</span>
        <span class="n">pop</span> <span class="n">all</span> <span class="n">local</span> <span class="n">variables</span> <span class="n">that</span> <span class="n">are</span> <span class="n">defined</span> <span class="n">at</span> <span class="n">the</span> <span class="n">current</span> <span class="n">point</span>
        <span class="n">but</span> <span class="n">not</span> <span class="n">at</span> <span class="err">$</span><span class="n">forI_end</span>
        <span class="n">jump</span><span class="p">(</span><span class="err">$</span><span class="n">forI_end</span><span class="p">)</span>
        <span class="mi">0</span> <span class="p">(</span><span class="kr">as</span> <span class="n">many</span> <span class="kr">as</span> <span class="n">variables</span> <span class="n">were</span> <span class="n">removed</span> <span class="n">above</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="s">&#39;continue&#39;</span> <span class="o">-&gt;</span>
      <span class="p">{</span>
        <span class="c1">// find nearest enclosing scope with label $forI_continue</span>
        <span class="n">pop</span> <span class="n">all</span> <span class="n">local</span> <span class="n">variables</span> <span class="n">that</span> <span class="n">are</span> <span class="n">defined</span> <span class="n">at</span> <span class="n">the</span> <span class="n">current</span> <span class="n">point</span>
        <span class="n">but</span> <span class="n">not</span> <span class="n">at</span> <span class="err">$</span><span class="n">forI_continue</span>
        <span class="n">jump</span><span class="p">(</span><span class="err">$</span><span class="n">forI_continue</span><span class="p">)</span>
        <span class="mi">0</span> <span class="p">(</span><span class="kr">as</span> <span class="n">many</span> <span class="kr">as</span> <span class="n">variables</span> <span class="n">were</span> <span class="n">removed</span> <span class="n">above</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="n">AssemblySwitch</span><span class="p">(</span><span class="n">switch</span> <span class="n">condition</span> <span class="n">cases</span> <span class="p">(</span> <span class="kr">default</span><span class="o">:</span> <span class="n">defaultBlock</span> <span class="p">)</span><span class="o">?</span> <span class="p">)</span> <span class="o">-&gt;</span>
      <span class="p">{</span>
        <span class="c1">// find I such that there is no $switchI* label or variable</span>
        <span class="n">let</span> <span class="err">$</span><span class="n">switchI_value</span> <span class="o">:=</span> <span class="n">condition</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">of</span> <span class="n">cases</span> <span class="n">match</span> <span class="p">{</span>
          <span class="n">case</span> <span class="n">val</span><span class="o">:</span> <span class="o">-&gt;</span> <span class="n">jumpi</span><span class="p">(</span><span class="err">$</span><span class="n">switchI_caseJ</span><span class="p">,</span> <span class="n">eq</span><span class="p">(</span><span class="err">$</span><span class="n">switchI_value</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="kr">default</span> <span class="nb">block</span> <span class="n">present</span><span class="o">:</span> <span class="o">-&gt;</span>
          <span class="p">{</span> <span class="n">defaultBlock</span> <span class="n">jump</span><span class="p">(</span><span class="err">$</span><span class="n">switchI_end</span><span class="p">)</span> <span class="p">}</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">of</span> <span class="n">cases</span> <span class="n">match</span> <span class="p">{</span>
          <span class="n">case</span> <span class="n">val</span><span class="o">:</span> <span class="p">{</span> <span class="n">body</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="err">$</span><span class="n">switchI_caseJ</span><span class="o">:</span> <span class="p">{</span> <span class="n">body</span> <span class="n">jump</span><span class="p">(</span><span class="err">$</span><span class="n">switchI_end</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="err">$</span><span class="n">switchI_end</span><span class="o">:</span>
      <span class="p">}</span>
    <span class="n">FunctionalAssemblyExpression</span><span class="p">(</span> <span class="n">identifier</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="p">...,</span> <span class="n">argn</span><span class="p">)</span> <span class="p">)</span> <span class="o">-&gt;</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="n">identifier</span> <span class="kr">is</span> <span class="kd">function</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span> <span class="n">with</span> <span class="n">n</span> <span class="n">args</span> <span class="n">and</span> <span class="n">m</span> <span class="n">ret</span> <span class="n">values</span> <span class="o">-&gt;</span>
          <span class="p">{</span>
            <span class="c1">// find I such that $funcallI_* does not exist</span>
            <span class="err">$</span><span class="n">funcallI_return</span> <span class="n">argn</span>  <span class="p">...</span> <span class="n">arg2</span> <span class="n">arg1</span> <span class="n">jump</span><span class="p">(</span><span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">)</span>
            <span class="n">pop</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">times</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">the</span> <span class="n">current</span> <span class="n">context</span> <span class="kr">is</span> <span class="err">`</span><span class="n">let</span> <span class="p">(</span><span class="n">id1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">idm</span><span class="p">)</span> <span class="o">:=</span> <span class="n">f</span><span class="p">(...)</span><span class="err">`</span> <span class="o">-&gt;</span>
              <span class="n">let</span> <span class="n">id1</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">...</span> <span class="n">let</span> <span class="n">idm</span> <span class="o">:=</span> <span class="mi">0</span>
              <span class="err">$</span><span class="n">funcallI_return</span><span class="o">:</span>
            <span class="k">else</span> <span class="o">-&gt;</span>
              <span class="mi">0</span> <span class="p">(</span><span class="n">m</span> <span class="n">times</span><span class="p">)</span>
              <span class="err">$</span><span class="n">funcallI_return</span><span class="o">:</span>
              <span class="n">turn</span> <span class="n">the</span> <span class="n">functional</span> <span class="n">expression</span> <span class="n">that</span> <span class="n">leads</span> <span class="n">to</span> <span class="n">the</span> <span class="kd">function</span> <span class="nb">call</span>
              <span class="n">into</span> <span class="n">a</span> <span class="n">statement</span> <span class="n">stream</span>
          <span class="p">}</span>
        <span class="k">else</span> <span class="o">-&gt;</span> <span class="n">desugar</span><span class="p">(</span><span class="n">children</span> <span class="n">of</span> <span class="n">node</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="kr">default</span> <span class="n">node</span> <span class="o">-&gt;</span>
      <span class="n">desugar</span><span class="p">(</span><span class="n">children</span> <span class="n">of</span> <span class="n">node</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div><h3 id="opcode-stream-generation">Opcode Stream Generation</h3><p>During opcode stream generation, we keep track of the current stack height in a counter, so that accessing stack variables by name is possible. The stack height is modified with every opcode that modifies the stack and with every label that is annotated with a stack adjustment. Every time a new local variable is introduced, it is registered together with the current stack height. If a variable is accessed (either for copying its value or for assignment), the appropriate <code>DUP</code> or <code>SWAP</code> instruction is selected depending on the difference between the current stack height and the stack height at the point the variable was introduced.</p><p>Pseudocode::</p><div class="codehilite"><pre><code class="language-solidity" data-lang="solidity"><span></span>    <span class="n">codegen</span> <span class="n">item</span><span class="o">:</span> <span class="n">AST</span> <span class="o">-&gt;</span> <span class="n">opcode_stream</span> <span class="o">=</span>
    <span class="n">match</span> <span class="n">item</span> <span class="p">{</span>
    <span class="n">AssemblyBlock</span><span class="p">({</span> <span class="n">items</span> <span class="p">})</span> <span class="o">-&gt;</span>
      <span class="n">join</span><span class="p">(</span><span class="n">codegen</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">items</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">last</span> <span class="n">generated</span> <span class="n">opcode</span> <span class="n">has</span> <span class="n">continuing</span> <span class="n">control</span> <span class="n">flow</span><span class="o">:</span>
        <span class="n">POP</span> <span class="k">for</span> <span class="n">all</span> <span class="n">local</span> <span class="n">variables</span> <span class="n">registered</span> <span class="n">at</span> <span class="n">the</span> <span class="nb">block</span> <span class="p">(</span><span class="n">including</span> <span class="n">variables</span>
        <span class="n">introduced</span> <span class="n">by</span> <span class="n">labels</span><span class="p">)</span>
        <span class="n">warn</span> <span class="k">if</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">height</span> <span class="n">at</span> <span class="nb">this</span> <span class="n">point</span> <span class="kr">is</span> <span class="n">not</span> <span class="n">the</span> <span class="n">same</span> <span class="kr">as</span> <span class="n">at</span> <span class="n">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">the</span> <span class="nb">block</span>
    <span class="n">Identifier</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">lookup</span> <span class="n">id</span> <span class="k">in</span> <span class="n">the</span> <span class="n">syntactic</span> <span class="n">stack</span> <span class="n">of</span> <span class="n">blocks</span>
      <span class="n">match</span> <span class="n">type</span> <span class="n">of</span> <span class="n">id</span>
        <span class="n">Local</span> <span class="n">Variable</span> <span class="o">-&gt;</span>
          <span class="n">DUPi</span> <span class="n">where</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">stack_height</span> <span class="o">-</span> <span class="n">stack_height_of_identifier</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
        <span class="n">Label</span> <span class="o">-&gt;</span>
          <span class="c1">// reference to be resolved during bytecode generation</span>
          <span class="n">PUSH</span><span class="o">&lt;</span><span class="n">bytecode</span> <span class="n">position</span> <span class="n">of</span> <span class="n">label</span><span class="o">&gt;</span>
        <span class="n">SubAssembly</span> <span class="o">-&gt;</span>
          <span class="n">PUSH</span><span class="o">&lt;</span><span class="n">bytecode</span> <span class="n">position</span> <span class="n">of</span> <span class="n">subassembly</span> <span class="n">data</span><span class="o">&gt;</span>
    <span class="n">FunctionalAssemblyExpression</span><span class="p">(</span><span class="n">id</span> <span class="p">(</span> <span class="n">arguments</span> <span class="p">)</span> <span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">join</span><span class="p">(</span><span class="n">codegen</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="k">in</span> <span class="n">arguments</span><span class="p">.</span><span class="n">reversed</span><span class="p">())</span>
      <span class="n">id</span> <span class="p">(</span><span class="n">which</span> <span class="n">has</span> <span class="n">to</span> <span class="n">be</span> <span class="n">an</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">might</span> <span class="n">be</span> <span class="n">a</span> <span class="kd">function</span> <span class="n">name</span> <span class="n">later</span><span class="p">)</span>
    <span class="n">AssemblyLocalDefinition</span><span class="p">(</span><span class="n">let</span> <span class="p">(</span><span class="n">id1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">idn</span><span class="p">)</span> <span class="o">:=</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">register</span> <span class="n">identifiers</span> <span class="n">id1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">idn</span> <span class="kr">as</span> <span class="n">locals</span> <span class="k">in</span> <span class="n">current</span> <span class="nb">block</span> <span class="n">at</span> <span class="n">current</span> <span class="n">stack</span> <span class="n">height</span>
      <span class="n">codegen</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">-</span> <span class="nb">assert</span> <span class="n">that</span> <span class="n">expr</span> <span class="k">returns</span> <span class="n">n</span> <span class="n">items</span> <span class="n">to</span> <span class="n">the</span> <span class="n">stack</span>
    <span class="n">FunctionalAssemblyAssignment</span><span class="p">((</span><span class="n">id1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">idn</span><span class="p">)</span> <span class="o">:=</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">lookup</span> <span class="n">id1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">idn</span> <span class="k">in</span> <span class="n">the</span> <span class="n">syntactic</span> <span class="n">stack</span> <span class="n">of</span> <span class="n">blocks</span><span class="p">,</span> <span class="nb">assert</span> <span class="n">that</span> <span class="n">they</span> <span class="n">are</span> <span class="n">variables</span>
      <span class="n">codegen</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span> <span class="p">...,</span> <span class="n">i</span><span class="o">:</span>
      <span class="n">SWAPi</span> <span class="n">where</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">stack_height</span> <span class="o">-</span> <span class="n">stack_height_of_identifier</span><span class="p">(</span><span class="n">idj</span><span class="p">)</span>
      <span class="n">POP</span>
    <span class="n">AssemblyAssignment</span><span class="p">(</span><span class="o">=:</span> <span class="n">id</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">look</span> <span class="n">up</span> <span class="n">id</span> <span class="k">in</span> <span class="n">the</span> <span class="n">syntactic</span> <span class="n">stack</span> <span class="n">of</span> <span class="n">blocks</span><span class="p">,</span> <span class="nb">assert</span> <span class="n">that</span> <span class="n">it</span> <span class="kr">is</span> <span class="n">a</span> <span class="n">variable</span>
      <span class="n">SWAPi</span> <span class="n">where</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">stack_height</span> <span class="o">-</span> <span class="n">stack_height_of_identifier</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
      <span class="n">POP</span>
    <span class="n">LabelDefinition</span><span class="p">(</span><span class="n">name</span><span class="o">:</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">JUMPDEST</span>
    <span class="n">NumberLiteral</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">PUSH</span><span class="o">&lt;</span><span class="n">num</span> <span class="n">interpreted</span> <span class="kr">as</span> <span class="n">decimal</span> <span class="n">and</span> <span class="n">right</span><span class="o">-</span><span class="n">aligned</span><span class="o">&gt;</span>
    <span class="n">HexLiteral</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">PUSH32</span><span class="o">&lt;</span><span class="n">lit</span> <span class="n">interpreted</span> <span class="kr">as</span> <span class="n">hex</span> <span class="n">and</span> <span class="n">left</span><span class="o">-</span><span class="n">aligned</span><span class="o">&gt;</span>
    <span class="n">StringLiteral</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">PUSH32</span><span class="o">&lt;</span><span class="n">lit</span> <span class="n">utf</span><span class="o">-</span><span class="mi">8</span> <span class="n">encoded</span> <span class="n">and</span> <span class="n">left</span><span class="o">-</span><span class="n">aligned</span><span class="o">&gt;</span>
    <span class="n">SubAssembly</span><span class="p">(</span><span class="k">assembly</span> <span class="err">&lt;</span><span class="n">name</span><span class="err">&gt;</span> <span class="n">block</span><span class="p">)</span> <span class="err">-&gt;</span>
      <span class="n">append</span> <span class="n">codegen</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="n">at</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">the</span> <span class="n">code</span>
    <span class="n">dataSize</span><span class="p">(</span><span class="err">&lt;</span><span class="n">name</span><span class="err">&gt;</span><span class="p">)</span> <span class="err">-&gt;</span>
      <span class="n">assert</span> <span class="n">that</span> <span class="err">&lt;</span><span class="n">name</span><span class="err">&gt;</span> <span class="n">is</span> <span class="n">a</span> <span class="n">subassembly</span> <span class="err">-&gt;</span>
      <span class="n">PUSH32</span><span class="err">&lt;</span><span class="n">size</span> <span class="n">of</span> <span class="n">code</span> <span class="n">generated</span> <span class="n">from</span> <span class="n">subassembly</span> <span class="err">&lt;</span><span class="n">name</span><span class="err">&gt;&gt;</span>
    <span class="n">linkerSymbol</span><span class="p">(</span><span class="err">&lt;</span><span class="n">lit</span><span class="err">&gt;</span><span class="p">)</span> <span class="err">-&gt;</span>
      <span class="n">PUSH32</span><span class="err">&lt;</span><span class="n">zeros</span><span class="err">&gt;</span> <span class="nf">and</span> <span class="n">append</span> <span class="n">position</span> <span class="n">to</span> <span class="n">linker</span> <span class="n">table</span>
    <span class="p">}</span>
</code></pre></div><h2 id="__source">source</h2><div><a href="https://github.com/ysqi/etheraction/blob/master/content/solidity/doc/assembly.md" title="github source file" class="md-source-file">assembly.md </a><a href="https://github.com/ysqi/etheraction/edit/master/content/solidity/doc/assembly.md" title="github source file" class="md-source-file">editor source file</a></div></article></div></div></main><footer class="md-footer"><div class="md-footer-nav"><nav class="md-footer-nav__inner md-grid"><a href="http://ethereum.mochain.info/solidity/doc/contracts.html" title="合约" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev"><div class="md-flex__cell md-flex__cell--shrink"><i class="md-icon md-icon--arrow-back md-footer-nav__button"></i></div><div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"><span class="md-flex__ellipsis"><span class="md-footer-nav__direction">previous</span> 合约</span></div></a><a href="http://ethereum.mochain.info/action/" title="实战" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next"><div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"><span class="md-flex__ellipsis"><span class="md-footer-nav__direction">next</span> 实战</span></div><div class="md-flex__cell md-flex__cell--shrink"><i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i></div></a></nav></div><div class="md-footer-meta md-typeset"><div class="md-footer-meta__inner md-grid"><div class="md-footer-copyright"><div class="md-footer-copyright__highlight">&copy; 2018 根据Apache 2.0 许可发布</div>powered by <a href="https://gohugo.io/" rel="nofollow">Hugo</a> and <a href="https://squidfunk.github.io/mkdocs-material/" rel="nofollow">Material for Hugo</a></div><div class="md-footer-social"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><a href="https://github.com/ysqi" class="md-footer-social__link fa fa-github"></a> <a href="https://yushuangqi.com" class="md-footer-social__link fa fa-wordpress"></a> <a href="https://weibo.com/234665601" class="md-footer-social__link fa fa-weibo"></a> <a href="https://www.zhihu.com/people/_ysqi/" class="md-footer-social__link fa fa-user-circle"></a> <a href="mailto:devysqi@gmail.com" class="md-footer-social__link fa fa-envelope-o"></a></div></div></div></footer></div><script>var base_url = '';
      var repo_id  = '';</script><script>var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");
      for(var i = 0; i < headers.length; i++) {
          var a = document.createElement("a");
          a.setAttribute("class", "headerlink");
          a.setAttribute("href", "#" + headers[i].id);
          a.setAttribute("title", "Permanent link")
          a.innerHTML = "¶";
          headers[i].appendChild(a);
      }</script><script src="http://ethereum.mochain.info/javascripts/application.js"></script><script>app.initialize({version:"0.17.2",url:{base:".."}})</script></body></html>